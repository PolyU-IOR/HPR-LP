var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api/#Parameters","page":"API Reference","title":"Parameters","text":"","category":"section"},{"location":"api/#Fields","page":"API Reference","title":"Fields","text":"Field Type Default Description\nstoptol Float64 1e-4 Stopping tolerance for convergence\nmax_iter Int typemax(Int32) Maximum number of iterations\ntime_limit Float64 3600.0 Time limit in seconds\ncheck_iter Int 150 Frequency of residual checks\nuse_Ruiz_scaling Bool true Enable Ruiz equilibration scaling\nuse_Pock_Chambolle_scaling Bool true Enable Pock-Chambolle scaling\nuse_bc_scaling Bool true Enable scaling for b and c vectors\nuse_gpu Bool true Use GPU acceleration if available\ndevice_number Int 0 GPU device number (for multi-GPU systems)\nwarm_up Bool true Perform warm-up run to compile code\nprint_frequency Int -1 Print frequency (-1 for automatic)\nverbose Bool true Print solver output","category":"section"},{"location":"api/#Example","page":"API Reference","title":"Example","text":"params = HPRLP_parameters()\nparams.stoptol = 1e-6       # Tighter tolerance\nparams.use_gpu = true       # Enable GPU\nparams.verbose = false      # Silent mode\nparams.time_limit = 3600    # 1 hour limit","category":"section"},{"location":"api/#Results","page":"API Reference","title":"Results","text":"","category":"section"},{"location":"api/#Fields-2","page":"API Reference","title":"Fields","text":"Field Type Description\niter Int Total number of iterations\niter_4, iter_6, iter_8 Int Iterations to reach 1e-4, 1e-6, 1e-8 accuracy\ntime Float64 Total solve time in seconds\ntime_4, time_6, time_8 Float64 Time to reach 1e-4, 1e-6, 1e-8 accuracy\npower_time Float64 Time spent in power method for eigenvalue estimation\nprimal_obj Float64 Primal objective value\nresiduals Float64 Relative residuals (primal, dual, gap)\ngap Float64 Duality gap\noutput_type String Status: \"OPTIMAL\", \"MAXITER\", or \"TIMELIMIT\"\nx Vector{Float64} Primal solution vector\ny Vector{Float64} Dual solution vector (constraints)\nz Vector{Float64} Dual solution vector (bounds)","category":"section"},{"location":"api/#Example-2","page":"API Reference","title":"Example","text":"result = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"Status: \", result.output_type)\nprintln(\"Objective: \", result.primal_obj)\nprintln(\"Solution: \", result.x)\nprintln(\"Iterations: \", result.iter)\nprintln(\"Time: \", result.time, \" seconds\")\nprintln(\"Residuals: \", result.residuals)","category":"section"},{"location":"api/#MOI/JuMP-Integration","page":"API Reference","title":"MOI/JuMP Integration","text":"","category":"section"},{"location":"api/#Optimizer","page":"API Reference","title":"Optimizer","text":"The Optimizer type implements the MathOptInterface (MOI) for integration with JuMP and other optimization modeling frameworks.","category":"section"},{"location":"api/#Supported-Attributes","page":"API Reference","title":"Supported Attributes","text":"","category":"section"},{"location":"api/#Optimizer-Attributes","page":"API Reference","title":"Optimizer Attributes","text":"MOI.Silent: Set to true for silent mode (equivalent to verbose = false)\nMOI.TimeLimitSec: Set time limit in seconds\nMOI.SolveTimeSec: Get solve time (after optimization)","category":"section"},{"location":"api/#Custom-Attributes-(via-MOI.RawOptimizerAttribute)","page":"API Reference","title":"Custom Attributes (via MOI.RawOptimizerAttribute)","text":"All fields from HPRLP_parameters can be set as raw optimizer attributes:\n\nusing JuMP, HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n# Standard MOI attributes\nset_silent(model)\nset_time_limit_sec(model, 3600.0)\n\n# Custom HPRLP attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-6)\nset_optimizer_attribute(model, \"use_gpu\", true)\nset_optimizer_attribute(model, \"use_Ruiz_scaling\", true)\nset_optimizer_attribute(model, \"device_number\", 0)","category":"section"},{"location":"api/#Supported-Problem-Types","page":"API Reference","title":"Supported Problem Types","text":"HPRLP supports linear programming problems with:\n\nObjective: Linear minimization or maximization\nVariables: Continuous with optional bounds\nConstraints: \nMOI.EqualTo: Equality constraints (Ax = b)\nMOI.LessThan: Upper bound constraints (Ax ≤ b)\nMOI.GreaterThan: Lower bound constraints (Ax ≥ b)\nMOI.Interval: Two-sided constraints (l ≤ Ax ≤ u)","category":"section"},{"location":"api/#Result-Queries","page":"API Reference","title":"Result Queries","text":"After calling optimize!(model):\n\n# Termination status\nstatus = termination_status(model)  # OPTIMAL, TIME_LIMIT, or ITERATION_LIMIT\n\n# Solution\nif has_values(model)\n    obj_val = objective_value(model)\n    x_val = value.(x)  # where x is your variable(s)\nend\n\n# Timing\nsolve_time = solve_time(model)","category":"section"},{"location":"api/#Internal-Functions","page":"API Reference","title":"Internal Functions","text":"The following functions are exported for advanced users but are primarily used internally:\n\nsolve(lp, scaling_info, params): Main solver routine\nformulation(lp, verbose): Convert QPS data to standard form\nscaling!(lp, use_Ruiz, use_PC, use_bc): Apply problem scaling\npower_iteration_gpu(...): Estimate maximum eigenvalue on GPU\npower_iteration_cpu(...): Estimate maximum eigenvalue on CPU","category":"section"},{"location":"api/#Function-Reference","page":"API Reference","title":"Function Reference","text":"","category":"section"},{"location":"api/#run_lp","page":"API Reference","title":"run_lp","text":"run_lp(A::SparseMatrixCSC,\n       AL::Vector{Float64},\n       AU::Vector{Float64},\n       c::Vector{Float64},\n       l::Vector{Float64},\n       u::Vector{Float64},\n       obj_constant::Float64,\n       params::HPRLP_parameters) -> HPRLP_results\n\nSolve a linear programming problem directly from matrix inputs.\n\nArguments:\n\nA: Sparse constraint matrix (m × n)\nAL: Lower bounds on constraints (m-vector)\nAU: Upper bounds on constraints (m-vector)\nc: Objective coefficients (n-vector)\nl: Lower bounds on variables (n-vector)\nu: Upper bounds on variables (n-vector)\nobj_constant: Constant term in objective\nparams: Solver parameters\n\nReturns: HPRLP_results containing solution and statistics","category":"section"},{"location":"api/#run_single","page":"API Reference","title":"run_single","text":"run_single(file_name::String, \n           params::HPRLP_parameters) -> HPRLP_results\n\nSolve a linear programming problem from an MPS file.\n\nArguments:\n\nfile_name: Path to MPS file (must have .mps extension)\nparams: Solver parameters\n\nReturns: HPRLP_results containing solution and statistics\n\nExample:\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = true\n\nresult = run_single(\"problem.mps\", params)","category":"section"},{"location":"api/#HPRLP.run_lp","page":"API Reference","title":"HPRLP.run_lp","text":"run_lp(A, AL, AU, c, l, u, obj_constant, params)\n\nSolve a linear program in standard form using the HPR-LP algorithm.\n\nArguments\n\nA::SparseMatrixCSC: Constraint matrix (m × n)\nAL::Vector{Float64}: Lower bounds for constraints Ax (length m)\nAU::Vector{Float64}: Upper bounds for constraints Ax (length m)\nc::Vector{Float64}: Objective coefficients (length n)\nl::Vector{Float64}: Lower bounds for variables x (length n)\nu::Vector{Float64}: Upper bounds for variables x (length n)\nobj_constant::Float64: Constant term in objective function\nparams::HPRLP_parameters: Solver parameters\n\nReturns\n\nHPRLP_results: Solution results including objective value, solution vector, and convergence info\n\nExample\n\nusing SparseArrays, HPRLP\n\n# min -3x - 5y\n# s.t. x + 2y ≤ 10\n#      3x + y ≤ 12\n#      x, y ≥ 0\n\nA = sparse([1.0 2.0; 3.0 1.0])\nAL = [-Inf, -Inf]\nAU = [10.0, 12.0]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\nparams = HPRLP_parameters()\nparams.verbose = false\n\nresults = run_lp(A, AL, AU, c, l, u, 0.0, params)\nprintln(\"Optimal value: \", results.primal_obj)\nprintln(\"Solution: \", results.x)\n\n\n\n\n\n","category":"function"},{"location":"api/#HPRLP.run_single","page":"API Reference","title":"HPRLP.run_single","text":"run_single(file_name, params)\n\nSolve a linear program from an MPS file using the HPR-LP algorithm.\n\nArguments\n\nfile_name::String: Path to the .mps file\nparams::HPRLP_parameters: Solver parameters\n\nReturns\n\nHPRLP_results: Solution results including objective value, solution vector, and convergence info\n\nExample\n\nusing HPRLP\n\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\nparams.verbose = true\n\nresults = run_single(\"problem.mps\", params)\n\nprintln(\"Status: \", results.status)\nprintln(\"Objective: \", results.primal_obj)\nprintln(\"Time: \", results.time, \" seconds\")\nprintln(\"Iterations: \", results.iter)\n\nSee also: run_lp, HPRLP_parameters, HPRLP_results\n\n\n\n\n\n","category":"function"},{"location":"api/#HPRLP.HPRLP_parameters","page":"API Reference","title":"HPRLP.HPRLP_parameters","text":"HPRLP_parameters\n\nParameters for the HPR-LP solver.\n\nFields\n\nstoptol::Float64: Stopping tolerance (default: 1e-4)\nmax_iter::Int: Maximum number of iterations (default: typemax(Int32))\ntime_limit::Float64: Time limit in seconds (default: 3600.0)\ncheck_iter::Int: Interval for residual checks (default: 150)\nuse_Ruiz_scaling::Bool: Enable Ruiz scaling (default: true)\nuse_Pock_Chambolle_scaling::Bool: Enable Pock-Chambolle scaling (default: true)\nuse_bc_scaling::Bool: Enable b/c scaling (default: true)\nuse_gpu::Bool: Use GPU acceleration (default: true)\ndevice_number::Int: GPU device number (default: 0)\nwarm_up::Bool: Enable warm-up phase (default: true)\nprint_frequency::Int: Print log every N iterations, -1 for auto (default: -1)\nverbose::Bool: Enable verbose output (default: true)\n\nExample\n\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\nparams.use_gpu = false\nparams.verbose = false\n\n\n\n\n\n","category":"type"},{"location":"api/#HPRLP.HPRLP_results","page":"API Reference","title":"HPRLP.HPRLP_results","text":"HPRLP_results\n\nResults from the HPR-LP solver.\n\nFields\n\niter::Int: Total number of iterations\niter_4::Int: Iterations to reach 1e-4 accuracy\niter_6::Int: Iterations to reach 1e-6 accuracy\niter_8::Int: Iterations to reach 1e-8 accuracy\ntime::Float64: Total solve time in seconds\ntime_4::Float64: Time to reach 1e-4 accuracy\ntime_6::Float64: Time to reach 1e-6 accuracy\ntime_8::Float64: Time to reach 1e-8 accuracy\nprimal_obj::Float64: Primal objective value\ndual_obj::Float64: Dual objective value\nprimal_residual::Float64: Final primal feasibility residual\ndual_residual::Float64: Final dual feasibility residual\nrelative_duality_gap::Float64: Final relative duality gap\nx::Vector{Float64}: Primal solution vector\nstatus::String: Termination status (\"Optimal\", \"TimeLimit\", \"IterationLimit\")\n\nExample\n\nresults = run_lp(A, b, c, l, u)\nprintln(\"Status: \", results.status)\nprintln(\"Objective: \", results.primal_obj)\nprintln(\"Time: \", results.time, \" seconds\")\n\n\n\n\n\n","category":"type"},{"location":"api/#HPRLP.Optimizer","page":"API Reference","title":"HPRLP.Optimizer","text":"Optimizer()\n\nCreate a new HPRLP Optimizer object.\n\nSet optimizer attributes using MOI.RawOptimizerAttribute or JuMP.set_optimizer_attribute.\n\nExample\n\nusing JuMP, HPRLP\nmodel = JuMP.Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\nset_optimizer_attribute(model, \"use_gpu\", true)\n\n\n\n\n\n","category":"type"},{"location":"guide/jump_integration/#JuMP-Integration","page":"JuMP Integration","title":"JuMP Integration","text":"HPRLP integrates seamlessly with JuMP through the MathOptInterface (MOI), allowing you to use HPRLP as a backend solver for JuMP models.","category":"section"},{"location":"guide/jump_integration/#Basic-Usage","page":"JuMP Integration","title":"Basic Usage","text":"using JuMP\nusing HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@objective(model, Min, -3x - 5y)\n@constraint(model, x + 2y <= 10)\n@constraint(model, 3x + y <= 12)\n\noptimize!(model)\n\nprintln(\"Optimal value: \", objective_value(model))\nprintln(\"x = \", value(x), \", y = \", value(y))","category":"section"},{"location":"guide/jump_integration/#Setting-Solver-Attributes","page":"JuMP Integration","title":"Setting Solver Attributes","text":"","category":"section"},{"location":"guide/jump_integration/#Using-set_optimizer_attribute","page":"JuMP Integration","title":"Using set_optimizer_attribute","text":"model = Model(HPRLP.Optimizer)\n\n# Standard MOI attributes\nset_silent(model)                      # Suppress output\nset_time_limit_sec(model, 3600.0)     # 1 hour time limit\n\n# HPRLP-specific attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-6)\nset_optimizer_attribute(model, \"use_gpu\", true)\nset_optimizer_attribute(model, \"device_number\", 0)\nset_optimizer_attribute(model, \"use_Ruiz_scaling\", true)\nset_optimizer_attribute(model, \"warm_up\", false)\nset_optimizer_attribute(model, \"max_iter\", 100000)","category":"section"},{"location":"guide/jump_integration/#All-Available-Attributes","page":"JuMP Integration","title":"All Available Attributes","text":"Attribute Type Default Description\n\"stoptol\" Float64 1e-4 Convergence tolerance\n\"max_iter\" Int typemax(Int32) Maximum iterations\n\"time_limit\" Float64 3600.0 Time limit (seconds)\n\"check_iter\" Int 150 Residual check frequency\n\"use_gpu\" Bool true Enable GPU\n\"device_number\" Int 0 GPU device number\n\"use_Ruiz_scaling\" Bool true Ruiz scaling\n\"use_Pock_Chambolle_scaling\" Bool true Pock-Chambolle scaling\n\"use_bc_scaling\" Bool true b/c scaling\n\"warm_up\" Bool true Warm-up phase\n\"print_frequency\" Int -1 Print frequency\n\"verbose\" Bool true Output verbosity","category":"section"},{"location":"guide/jump_integration/#Querying-Results","page":"JuMP Integration","title":"Querying Results","text":"","category":"section"},{"location":"guide/jump_integration/#Termination-Status","page":"JuMP Integration","title":"Termination Status","text":"optimize!(model)\n\nstatus = termination_status(model)\n\nif status == MOI.OPTIMAL\n    println(\"Optimal solution found!\")\nelseif status == MOI.TIME_LIMIT\n    println(\"Time limit reached\")\nelseif status == MOI.ITERATION_LIMIT\n    println(\"Iteration limit reached\")\nend","category":"section"},{"location":"guide/jump_integration/#Objective-and-Solutions","page":"JuMP Integration","title":"Objective and Solutions","text":"if has_values(model)\n    obj_val = objective_value(model)\n    x_val = value(x)\n    y_val = value(y)\n    \n    println(\"Objective: $obj_val\")\n    println(\"x = $x_val, y = $y_val\")\nend","category":"section"},{"location":"guide/jump_integration/#Solve-Time","page":"JuMP Integration","title":"Solve Time","text":"time = solve_time(model)\nprintln(\"Solved in $time seconds\")","category":"section"},{"location":"guide/jump_integration/#Silent-Mode","page":"JuMP Integration","title":"Silent Mode","text":"Suppress all solver output:\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n# Build model...\noptimize!(model)\n# No output from solver\n\nOr equivalently:\n\nmodel = Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"verbose\", false)\noptimize!(model)","category":"section"},{"location":"guide/jump_integration/#Common-Patterns","page":"JuMP Integration","title":"Common Patterns","text":"","category":"section"},{"location":"guide/jump_integration/#Production-Portfolio","page":"JuMP Integration","title":"Production Portfolio","text":"using JuMP, HPRLP\n\n# Production planning\nproducts = 1:5\nresources = 1:3\n\nprofit = rand(5) .* 10\nresource_usage = rand(3, 5)\nresource_capacity = rand(3) .* 100\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, production[products] >= 0)\n@objective(model, Max, sum(profit[p] * production[p] for p in products))\n\nfor r in resources\n    @constraint(model, \n        sum(resource_usage[r,p] * production[p] for p in products) \n        <= resource_capacity[r]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    println(\"Optimal profit: \", objective_value(model))\n    for p in products\n        println(\"Product $p: \", value(production[p]))\n    end\nend","category":"section"},{"location":"guide/jump_integration/#Network-Flow","page":"JuMP Integration","title":"Network Flow","text":"using JuMP, HPRLP\n\n# Simple network flow\nnodes = 1:5\narcs = [(1,2), (1,3), (2,4), (3,4), (4,5)]\ncapacity = Dict(arcs .=> rand(length(arcs)) .* 10)\nsupply = [10.0, 0, 0, 0, -10]  # Source at 1, sink at 5\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, 0 <= flow[a in arcs] <= capacity[a])\n@objective(model, Min, sum(flow[a] for a in arcs))  # Min total flow\n\n# Flow conservation\nfor n in nodes\n    incoming = [a for a in arcs if a[2] == n]\n    outgoing = [a for a in arcs if a[1] == n]\n    \n    @constraint(model,\n        sum(flow[a] for a in incoming) - \n        sum(flow[a] for a in outgoing) == -supply[n]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    for a in arcs\n        if value(flow[a]) > 1e-6\n            println(\"Arc $a: \", value(flow[a]))\n        end\n    end\nend","category":"section"},{"location":"guide/jump_integration/#Diet-Problem","page":"JuMP Integration","title":"Diet Problem","text":"using JuMP, HPRLP\n\n# Classic diet problem\nfoods = [\"Bread\", \"Milk\", \"Eggs\", \"Meat\", \"Cake\"]\nnutrients = [\"Calories\", \"Protein\", \"Fat\"]\n\ncost = [2.0, 3.5, 2.5, 8.0, 5.0]\nnutrition = [\n    300 200 100 400 500;  # Calories\n     10  15  12  30   5;  # Protein (g)\n      5  10   8  20  15   # Fat (g)\n]\nmin_nutrient = [2000, 50, 30]  # Daily requirements\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, servings[1:5] >= 0)\n@objective(model, Min, sum(cost[i] * servings[i] for i in 1:5))\n\nfor n in 1:3\n    @constraint(model,\n        sum(nutrition[n,f] * servings[f] for f in 1:5) >= min_nutrient[n]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    println(\"Minimum cost: \\$\", objective_value(model))\n    for (i, food) in enumerate(foods)\n        if value(servings[i]) > 1e-6\n            println(\"$food: \", value(servings[i]), \" servings\")\n        end\n    end\nend","category":"section"},{"location":"guide/jump_integration/#GPU-Acceleration","page":"JuMP Integration","title":"GPU Acceleration","text":"Enable GPU for large models:\n\nmodel = Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"use_gpu\", true)\nset_optimizer_attribute(model, \"device_number\", 0)\n\n# Build large model...\n# ...\n\noptimize!(model)","category":"section"},{"location":"guide/jump_integration/#Maximization-Problems","page":"JuMP Integration","title":"Maximization Problems","text":"JuMP automatically handles maximization:\n\nmodel = Model(HPRLP.Optimizer)\n\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n\n# Maximization (automatically converted to minimization internally)\n@objective(model, Max, 3x + 5y)\n\n@constraint(model, x + 2y <= 10)\n@constraint(model, 3x + y <= 12)\n\noptimize!(model)\nprintln(\"Maximum value: \", objective_value(model))","category":"section"},{"location":"guide/jump_integration/#Error-Handling","page":"JuMP Integration","title":"Error Handling","text":"model = Model(HPRLP.Optimizer)\n\n# Build model...\n\ntry\n    optimize!(model)\n    \n    if termination_status(model) == MOI.OPTIMAL\n        println(\"Success!\")\n    else\n        println(\"Solver terminated with status: \", termination_status(model))\n        if has_values(model)\n            println(\"Best solution found: \", objective_value(model))\n        end\n    end\ncatch e\n    println(\"Error during optimization: \", e)\nend","category":"section"},{"location":"guide/jump_integration/#Reading-MPS-Files-with-JuMP","page":"JuMP Integration","title":"Reading MPS Files with JuMP","text":"You can read MPS files and solve them with HPRLP via JuMP:\n\nusing JuMP, HPRLP\n\nmodel = read_from_file(\"problem.mps\")\nset_optimizer(model, HPRLP.Optimizer)\n\n# Set attributes\nset_silent(model)\nset_optimizer_attribute(model, \"stoptol\", 1e-6)\n\n# Solve\noptimize!(model)\n\nprintln(\"Status: \", termination_status(model))\nif has_values(model)\n    println(\"Objective: \", objective_value(model))\nend","category":"section"},{"location":"guide/jump_integration/#Comparison-with-Other-Solvers","page":"JuMP Integration","title":"Comparison with Other Solvers","text":"Easy to switch between solvers:\n\nusing JuMP, HPRLP, HiGHS\n\n# Build model\nfunction build_model()\n    model = Model()\n    @variable(model, x >= 0)\n    @variable(model, y >= 0)\n    @objective(model, Min, -3x - 5y)\n    @constraint(model, x + 2y <= 10)\n    @constraint(model, 3x + y <= 12)\n    return model\nend\n\n# Solve with HPRLP\nmodel1 = build_model()\nset_optimizer(model1, HPRLP.Optimizer)\nset_silent(model1)\noptimize!(model1)\nprintln(\"HPRLP: \", objective_value(model1))\n\n# Solve with HiGHS\nmodel2 = build_model()\nset_optimizer(model2, HiGHS.Optimizer)\nset_silent(model2)\noptimize!(model2)\nprintln(\"HiGHS: \", objective_value(model2))","category":"section"},{"location":"guide/jump_integration/#Performance-Tips","page":"JuMP Integration","title":"Performance Tips","text":"Set silent mode for faster execution in production\nDisable warm-up if solving many small problems\nUse GPU for problems with > 10,000 variables\nAdjust tolerance based on application needs\nReuse models when solving similar problems repeatedly","category":"section"},{"location":"guide/jump_integration/#Troubleshooting","page":"JuMP Integration","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/jump_integration/#Model-Not-Solving","page":"JuMP Integration","title":"Model Not Solving","text":"Check if the model is properly built:\n\nprintln(\"Number of variables: \", num_variables(model))\nprintln(\"Number of constraints: \", num_constraints(model, AffExpr, MOI.LessThan{Float64}))","category":"section"},{"location":"guide/jump_integration/#Slow-First-Run","page":"JuMP Integration","title":"Slow First Run","text":"Julia's JIT compilation causes slow first runs. Use warm-up:\n\nset_optimizer_attribute(model, \"warm_up\", true)  # Default","category":"section"},{"location":"guide/jump_integration/#GPU-Errors","page":"JuMP Integration","title":"GPU Errors","text":"If GPU fails, solver automatically falls back to CPU. To force CPU:\n\nset_optimizer_attribute(model, \"use_gpu\", false)","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"Before using HPRLP, ensure you have:\n\nJulia (version 1.10 or higher recommended)\nCUDA (optional, for GPU acceleration)\nCUDA-capable GPU with compute capability 5.0 or higher\nCUDA Toolkit 11.0 or higher","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/#From-Julia-General-Registry-(after-registration)","page":"Getting Started","title":"From Julia General Registry (after registration)","text":"using Pkg\nPkg.add(\"HPRLP\")","category":"section"},{"location":"getting_started/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"using Pkg\nPkg.add(url=\"https://github.com/PolyU-IOR/HPR-LP\")","category":"section"},{"location":"getting_started/#Development-Installation","page":"Getting Started","title":"Development Installation","text":"To install for development:\n\ngit clone https://github.com/PolyU-IOR/HPR-LP.git\ncd HPR-LP\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"getting_started/#Verifying-CUDA-Installation","page":"Getting Started","title":"Verifying CUDA Installation","text":"If you plan to use GPU acceleration, verify CUDA is working:\n\nusing CUDA\nCUDA.versioninfo()\n\nIf CUDA is not available, HPRLP will automatically fall back to CPU mode.","category":"section"},{"location":"getting_started/#First-Example:-Solving-a-Simple-LP","page":"Getting Started","title":"First Example: Solving a Simple LP","text":"Let's solve a basic linear programming problem:\n\nbeginarrayll\nmin quad  -3x_1 - 5x_2 \ntextst quad  x_1 + 2x_2 leq 10 \n 3x_1 + x_2 leq 12 \n x_1 x_2 geq 0\nendarray","category":"section"},{"location":"getting_started/#Using-the-Direct-API","page":"Getting Started","title":"Using the Direct API","text":"using HPRLP\nusing SparseArrays\n\n# Convert to standard form: AL ≤ Ax ≤ AU\n# Inequality ax + by ≤ c becomes -ax - by ≥ -c (i.e., AL = -c, AU = ∞)\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\nobj_constant = 0.0\n\n# Set up parameters\nparams = HPRLP_parameters()\nparams.use_gpu = false      # Use CPU for this small problem\nparams.stoptol = 1e-4      # Convergence tolerance\nparams.time_limit = 60     # Maximum 60 seconds\nparams.verbose = true      # Print solver output\n\n# Solve\nresult = run_lp(A, AL, AU, c, l, u, obj_constant, params)\n\n# Check results\nprintln(\"Status: \", result.output_type)\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: x₁ = \", result.x[1], \", x₂ = \", result.x[2])\nprintln(\"Iterations: \", result.iter)\nprintln(\"Solve time: \", result.time, \" seconds\")\n\nExpected output:\n\nOptimal value: -26.4\nSolution: x₁ ≈ 2.8, x₂ ≈ 3.6","category":"section"},{"location":"getting_started/#Using-JuMP","page":"Getting Started","title":"Using JuMP","text":"The same problem using the JuMP modeling interface:\n\nusing JuMP\nusing HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n# Set optimizer attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\nset_optimizer_attribute(model, \"use_gpu\", false)\nset_optimizer_attribute(model, \"verbose\", true)\n\n# Define variables and constraints\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, x1 + 2x2 <= 10)\n@constraint(model, 3x1 + x2 <= 12)\n\n# Solve\noptimize!(model)\n\n# Get results\nprintln(\"Status: \", termination_status(model))\nprintln(\"Optimal value: \", objective_value(model))\nprintln(\"Solution: x₁ = \", value(x1), \", x₂ = \", value(x2))\nprintln(\"Solve time: \", solve_time(model), \" seconds\")","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about solving MPS files\nExplore the Direct API in detail\nSee more JuMP integration examples\nCheck out the full API Reference\nBrowse additional Examples","category":"section"},{"location":"getting_started/#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"JIT Compilation: The first run will be slow due to Julia's JIT compilation. For benchmarking, run the solver twice or use a warm-up phase.\nGPU Usage: For large problems (typically > 10,000 variables/constraints), GPU acceleration can provide significant speedups.\nScaling: The default scaling methods (Ruiz and Pock-Chambolle) improve numerical stability. Keep them enabled unless you have specific reasons to disable them.\nTolerance: The default stoptol = 1e-4 balances accuracy and speed. Increase for tighter solutions or decrease for faster approximate solutions.","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"This page provides complete, runnable examples demonstrating various use cases of HPRLP.","category":"section"},{"location":"examples/#Example-1:-Basic-Linear-Program","page":"Examples","title":"Example 1: Basic Linear Program","text":"Solve a simple 2-variable LP problem.\n\nusing HPRLP\nusing SparseArrays\n\n# Problem:\n# min  -3x₁ - 5x₂\n# s.t.  x₁ + 2x₂ ≤ 10\n#      3x₁ +  x₂ ≤ 12\n#      x₁, x₂ ≥ 0\n\n# Standard form: AL ≤ Ax ≤ AU\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = true\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"\\n=== Results ===\")\nprintln(\"Status: \", result.output_type)\nprintln(\"Objective value: \", result.primal_obj)\nprintln(\"x₁ = \", result.x[1])\nprintln(\"x₂ = \", result.x[2])\nprintln(\"Iterations: \", result.iter)\nprintln(\"Time: \", result.time, \" seconds\")","category":"section"},{"location":"examples/#Example-2:-Solving-an-MPS-File","page":"Examples","title":"Example 2: Solving an MPS File","text":"Read and solve a problem from an MPS file.\n\nusing HPRLP\n\n# Configure solver\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6        # High accuracy\nparams.use_gpu = true        # Enable GPU\nparams.verbose = true        # Show progress\nparams.time_limit = 3600     # 1 hour limit\n\n# Solve\nresult = run_single(\"path/to/problem.mps\", params)\n\n# Display results\nif result.output_type == \"OPTIMAL\"\n    println(\"✓ Optimal solution found!\")\n    println(\"  Objective: \", result.primal_obj)\n    println(\"  Iterations: \", result.iter)\n    println(\"  Time: \", result.time, \" seconds\")\n    println(\"  Residuals: \", result.residuals)\nelse\n    println(\"⚠ Solver stopped: \", result.output_type)\n    println(\"  Best objective: \", result.primal_obj)\nend","category":"section"},{"location":"examples/#Example-3:-JuMP-Model","page":"Examples","title":"Example 3: JuMP Model","text":"Build and solve using JuMP's modeling language.\n\nusing JuMP, HPRLP\n\n# Create model\nmodel = Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\nset_optimizer_attribute(model, \"use_gpu\", false)\n\n# Define problem\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, c1, x1 + 2x2 <= 10)\n@constraint(model, c2, 3x1 + x2 <= 12)\n\n# Solve\noptimize!(model)\n\n# Results\nprintln(\"Status: \", termination_status(model))\nprintln(\"Optimal value: \", objective_value(model))\nprintln(\"x1 = \", value(x1))\nprintln(\"x2 = \", value(x2))\nprintln(\"Solve time: \", solve_time(model), \" seconds\")","category":"section"},{"location":"examples/#Example-4:-Production-Planning","page":"Examples","title":"Example 4: Production Planning","text":"A realistic production planning problem.\n\nusing JuMP, HPRLP\n\n# Problem data\nn_products = 10\nn_resources = 5\n\n# Profit per unit\nprofit = [50, 60, 40, 70, 55, 45, 65, 48, 52, 58]\n\n# Resource usage (resources × products)\nresource_usage = [\n    2 3 1 4 2 1 3 2 1 3;\n    1 2 2 1 3 2 1 2 3 1;\n    3 1 2 2 1 3 2 1 2 2;\n    1 1 1 2 2 1 3 1 1 2;\n    2 2 3 1 1 2 1 3 2 1\n]\n\n# Available resources\ncapacity = [100, 80, 120, 90, 110]\n\n# Build model\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, production[1:n_products] >= 0)\n@objective(model, Max, sum(profit[p] * production[p] for p in 1:n_products))\n\nfor r in 1:n_resources\n    @constraint(model, \n        sum(resource_usage[r,p] * production[p] for p in 1:n_products) \n        <= capacity[r]\n    )\nend\n\n# Solve\noptimize!(model)\n\n# Display solution\nprintln(\"=== Production Plan ===\")\nprintln(\"Total Profit: \\$\", round(objective_value(model), digits=2))\nprintln(\"\\nProduction Quantities:\")\nfor p in 1:n_products\n    qty = value(production[p])\n    if qty > 0.01\n        revenue = profit[p] * qty\n        println(\"  Product $p: \", round(qty, digits=2), \n                \" units (revenue: \\$\", round(revenue, digits=2), \")\")\n    end\nend","category":"section"},{"location":"examples/#Example-5:-Transportation-Problem","page":"Examples","title":"Example 5: Transportation Problem","text":"Classical transportation problem.\n\nusing JuMP, HPRLP\n\n# Supply at each factory\nfactories = 1:3\nsupply = [300, 400, 500]\n\n# Demand at each warehouse\nwarehouses = 1:4\ndemand = [250, 350, 200, 400]\n\n# Transportation costs (factories × warehouses)\ncost = [\n    4 6 8 5;\n    3 7 9 4;\n    5 5 6 7\n]\n\n# Build model\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, ship[f in factories, w in warehouses] >= 0)\n@objective(model, Min, \n    sum(cost[f,w] * ship[f,w] for f in factories, w in warehouses)\n)\n\n# Supply constraints\nfor f in factories\n    @constraint(model, sum(ship[f,w] for w in warehouses) <= supply[f])\nend\n\n# Demand constraints\nfor w in warehouses\n    @constraint(model, sum(ship[f,w] for f in factories) >= demand[w])\nend\n\n# Solve\noptimize!(model)\n\n# Display solution\nprintln(\"=== Transportation Plan ===\")\nprintln(\"Total Cost: \\$\", round(objective_value(model), digits=2))\nprintln(\"\\nShipments:\")\nfor f in factories\n    for w in warehouses\n        qty = value(ship[f,w])\n        if qty > 0.01\n            println(\"  Factory $f → Warehouse $w: \", \n                    round(qty, digits=0), \" units\")\n        end\n    end\nend","category":"section"},{"location":"examples/#Example-6:-Portfolio-Optimization","page":"Examples","title":"Example 6: Portfolio Optimization","text":"Simple portfolio selection problem.\n\nusing HPRLP\nusing SparseArrays\nusing LinearAlgebra\n\n# Number of assets\nn_assets = 50\n\n# Expected returns\nexpected_returns = 0.05 .+ 0.10 * rand(n_assets)\n\n# Constraints\nA = sparse(ones(1, n_assets))  # Sum of weights\nAL = [1.0]                      # = 1 (fully invested)\nAU = [1.0]\n\n# Objective: maximize expected return (min -return)\nc = -expected_returns\n\n# Variable bounds: 0 ≤ w ≤ 0.1 (max 10% per asset)\nl = zeros(n_assets)\nu = 0.1 * ones(n_assets)\n\n# Solve\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = false\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\n# Results\nweights = result.x\nexpected_portfolio_return = -result.primal_obj\n\nprintln(\"=== Portfolio ===\")\nprintln(\"Expected Return: \", round(expected_portfolio_return * 100, digits=2), \"%\")\nprintln(\"Number of Assets: \", count(weights .> 1e-6))\nprintln(\"\\nTop 5 Holdings:\")\nsorted_idx = sortperm(weights, rev=true)\nfor i in 1:min(5, n_assets)\n    idx = sorted_idx[i]\n    if weights[idx] > 1e-6\n        println(\"  Asset $idx: \", round(weights[idx] * 100, digits=2), \n                \"% (return: \", round(expected_returns[idx] * 100, digits=2), \"%)\")\n    end\nend","category":"section"},{"location":"examples/#Example-7:-Batch-Processing","page":"Examples","title":"Example 7: Batch Processing","text":"Solve multiple problems in batch.\n\nusing HPRLP\n\nfunction solve_batch_problems(files::Vector{String}, output_csv::String)\n    # Setup\n    params = HPRLP_parameters()\n    params.verbose = false\n    params.use_gpu = true\n    params.time_limit = 600  # 10 minutes per problem\n    \n    # Results storage\n    results = []\n    \n    println(\"Processing $(length(files)) files...\")\n    \n    for (i, file) in enumerate(files)\n        println(\"  [$i/$(length(files))] $file\")\n        \n        try\n            result = run_single(file, params)\n            \n            push!(results, (\n                file = basename(file),\n                status = result.output_type,\n                objective = result.primal_obj,\n                iterations = result.iter,\n                time = result.time,\n                residuals = result.residuals\n            ))\n            \n            println(\"    ✓ $(result.output_type) in $(round(result.time, digits=2))s\")\n        catch e\n            println(\"    ✗ ERROR: $e\")\n            push!(results, (\n                file = basename(file),\n                status = \"ERROR\",\n                objective = NaN,\n                iterations = 0,\n                time = 0.0,\n                residuals = NaN\n            ))\n        end\n    end\n    \n    # Save results (simplified - use CSV.jl for real implementation)\n    open(output_csv, \"w\") do io\n        println(io, \"File,Status,Objective,Iterations,Time,Residuals\")\n        for r in results\n            println(io, \"$(r.file),$(r.status),$(r.objective),$(r.iterations),$(r.time),$(r.residuals)\")\n        end\n    end\n    \n    println(\"\\nResults saved to: $output_csv\")\n    return results\nend\n\n# Usage\nfiles = [\"problem1.mps\", \"problem2.mps\", \"problem3.mps\"]\nresults = solve_batch_problems(files, \"results.csv\")","category":"section"},{"location":"examples/#Example-8:-Comparing-Solvers","page":"Examples","title":"Example 8: Comparing Solvers","text":"Compare HPRLP with other solvers.\n\nusing JuMP, HPRLP, HiGHS\nusing BenchmarkTools\n\nfunction build_test_problem()\n    model = Model()\n    \n    # Large random LP\n    n = 1000\n    m = 500\n    \n    @variable(model, x[1:n] >= 0)\n    @objective(model, Min, sum(rand() * x[i] for i in 1:n))\n    \n    for j in 1:m\n        @constraint(model, \n            sum(rand() * x[i] for i in 1:n) <= 100\n        )\n    end\n    \n    return model\nend\n\n# Test HPRLP (CPU)\nmodel1 = build_test_problem()\nset_optimizer(model1, HPRLP.Optimizer)\nset_silent(model1)\nset_optimizer_attribute(model1, \"use_gpu\", false)\n@time optimize!(model1)\nprintln(\"HPRLP (CPU): \", objective_value(model1))\n\n# Test HPRLP (GPU)\nmodel2 = build_test_problem()\nset_optimizer(model2, HPRLP.Optimizer)\nset_silent(model2)\nset_optimizer_attribute(model2, \"use_gpu\", true)\n@time optimize!(model2)\nprintln(\"HPRLP (GPU): \", objective_value(model2))\n\n# Test HiGHS\nmodel3 = build_test_problem()\nset_optimizer(model3, HiGHS.Optimizer)\nset_silent(model3)\n@time optimize!(model3)\nprintln(\"HiGHS: \", objective_value(model3))","category":"section"},{"location":"examples/#Example-9:-Warm-up-for-Performance","page":"Examples","title":"Example 9: Warm-up for Performance","text":"Demonstrate warm-up benefit.\n\nusing HPRLP\nusing SparseArrays\n\n# Problem definition\nA = sparse(rand(100, 200))\nAL = zeros(100)\nAU = 100 * ones(100)\nc = rand(200)\nl = zeros(200)\nu = 100 * ones(200)\n\n# Without warm-up (cold start)\nparams_cold = HPRLP_parameters()\nparams_cold.warm_up = false\nparams_cold.verbose = false\nparams_cold.use_gpu = false\n\nprintln(\"=== Cold Start ===\")\n@time result1 = run_lp(A, AL, AU, c, l, u, 0.0, params_cold)\nprintln(\"Solve time: \", result1.time)\n\n# With warm-up (subsequent runs faster)\nparams_warm = HPRLP_parameters()\nparams_warm.warm_up = true\nparams_warm.verbose = false\nparams_warm.use_gpu = false\n\nprintln(\"\\n=== With Warm-up ===\")\n@time result2 = run_lp(A, AL, AU, c, l, u, 0.0, params_warm)\nprintln(\"Solve time: \", result2.time)\n\n# Second run (already compiled)\nprintln(\"\\n=== Second Run (Already Compiled) ===\")\n@time result3 = run_lp(A, AL, AU, c, l, u, 0.0, params_warm)\nprintln(\"Solve time: \", result3.time)","category":"section"},{"location":"examples/#Running-the-Examples","page":"Examples","title":"Running the Examples","text":"All examples can be run directly after installing HPRLP:\n\nusing Pkg\nPkg.add(\"HPRLP\")  # or add from GitHub\n\n# Copy and paste any example above\n# ...\n\nFor more examples, see the demo directory in the repository.","category":"section"},{"location":"guide/direct_api/#Direct-API-Usage","page":"Direct API","title":"Direct API Usage","text":"The direct API allows you to solve LP problems by passing matrices and vectors directly, without using MPS files or modeling languages.","category":"section"},{"location":"guide/direct_api/#Basic-Example","page":"Direct API","title":"Basic Example","text":"using HPRLP\nusing SparseArrays\n\n# Problem: min -3x₁ - 5x₂\n#          s.t. x₁ + 2x₂ ≤ 10\n#               3x₁ + x₂ ≤ 12\n#               x₁, x₂ ≥ 0\n\n# Convert to standard form: AL ≤ Ax ≤ AU\nA = sparse([-1.0 -2.0; -3.0 -1.0])  # Note the negation\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: \", result.x)","category":"section"},{"location":"guide/direct_api/#Standard-Form-Convention","page":"Direct API","title":"Standard Form Convention","text":"HPRLP uses the convention:\n\nbeginarrayll\nmin quad  c^T x \ntextst quad  AL leq Ax leq AU \n l leq x leq u\nendarray","category":"section"},{"location":"guide/direct_api/#Converting-Common-Forms","page":"Direct API","title":"Converting Common Forms","text":"","category":"section"},{"location":"guide/direct_api/#From-Inequalities","page":"Direct API","title":"From ≤ Inequalities","text":"Original: a^T x leq b\n\nStandard form:\n\nRow of A: a^T\nAL_i = -infty\nAU_i = b\n\nOr equivalently:\n\nRow of A: -a^T\nAL_i = -b\nAU_i = +infty","category":"section"},{"location":"guide/direct_api/#From-Inequalities-2","page":"Direct API","title":"From ≥ Inequalities","text":"Original: a^T x geq b\n\nStandard form:\n\nRow of A: a^T\nAL_i = b\nAU_i = +infty\n\nOr equivalently:\n\nRow of A: -a^T\nAL_i = -infty\nAU_i = -b","category":"section"},{"location":"guide/direct_api/#From-Equalities","page":"Direct API","title":"From Equalities","text":"Original: a^T x = b\n\nStandard form:\n\nRow of A: a^T\nAL_i = b\nAU_i = b","category":"section"},{"location":"guide/direct_api/#Two-Sided-Constraints","page":"Direct API","title":"Two-Sided Constraints","text":"Original: l_i leq a^T x leq u_i\n\nStandard form:\n\nRow of A: a^T\nAL_i = l_i\nAU_i = u_i","category":"section"},{"location":"guide/direct_api/#Complete-Example-with-All-Constraint-Types","page":"Direct API","title":"Complete Example with All Constraint Types","text":"using HPRLP\nusing SparseArrays\n\n# Problem with mixed constraints:\n# min   x₁ + 2x₂ + 3x₃\n# s.t.  x₁ + x₂ + x₃ = 5      (equality)\n#       x₁ + 2x₂ ≤ 8          (upper bound)\n#       2x₁ + x₃ ≥ 3          (lower bound)\n#       1 ≤ x₂ + x₃ ≤ 6       (two-sided)\n#       0 ≤ x₁ ≤ 5, x₂ ≥ 0, x₃ free\n\n# Constraint matrix\nA = sparse([\n    1.0  1.0  1.0;   # x₁ + x₂ + x₃ = 5\n    1.0  2.0  0.0;   # x₁ + 2x₂ ≤ 8\n    2.0  0.0  1.0;   # 2x₁ + x₃ ≥ 3\n    0.0  1.0  1.0    # 1 ≤ x₂ + x₃ ≤ 6\n])\n\n# Constraint bounds\nAL = [5.0, -Inf, 3.0, 1.0]\nAU = [5.0, 8.0, Inf, 6.0]\n\n# Objective\nc = [1.0, 2.0, 3.0]\n\n# Variable bounds (free variables: l = -Inf, u = Inf)\nl = [0.0, 0.0, -Inf]\nu = [5.0, Inf, Inf]\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = true\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"\\nResults:\")\nprintln(\"Status: \", result.output_type)\nprintln(\"Objective: \", result.primal_obj)\nprintln(\"Solution: x = \", result.x)","category":"section"},{"location":"guide/direct_api/#Working-with-Dense-Matrices","page":"Direct API","title":"Working with Dense Matrices","text":"If your problem uses dense matrices, convert to sparse:\n\nusing SparseArrays\n\n# Dense matrix\nA_dense = [1.0 2.0 3.0;\n           4.0 5.0 6.0;\n           7.0 8.0 9.0]\n\n# Convert to sparse\nA_sparse = sparse(A_dense)\n\n# Then solve as usual\nresult = run_lp(A_sparse, AL, AU, c, l, u, 0.0, params)","category":"section"},{"location":"guide/direct_api/#Constructing-Sparse-Matrices","page":"Direct API","title":"Constructing Sparse Matrices","text":"","category":"section"},{"location":"guide/direct_api/#From-Triplet-Format","page":"Direct API","title":"From Triplet Format","text":"# Row indices, column indices, values\nrows = [1, 1, 2, 2, 3]\ncols = [1, 2, 2, 3, 3]\nvals = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n# Create sparse matrix\nA = sparse(rows, cols, vals, 3, 3)  # 3×3 matrix","category":"section"},{"location":"guide/direct_api/#Pattern-Matrices","page":"Direct API","title":"Pattern Matrices","text":"using SparseArrays\n\n# Identity matrix\nn = 100\nA = sparse(I, n, n)\n\n# Tridiagonal matrix\nA = spdiagm(-1 => ones(n-1), 0 => 2*ones(n), 1 => ones(n-1))\n\n# Random sparse matrix\nA = sprand(1000, 500, 0.01)  # 1000×500, 1% density","category":"section"},{"location":"guide/direct_api/#GPU-Acceleration","page":"Direct API","title":"GPU Acceleration","text":"For large problems, enable GPU acceleration:\n\nparams = HPRLP_parameters()\nparams.use_gpu = true\nparams.device_number = 0  # First GPU\n\n# The solver automatically transfers data to GPU\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nWhen to use GPU:\n\nProblem has > 10,000 variables or constraints\nConstraint matrix has > 100,000 nonzeros\nYou have a CUDA-capable GPU available","category":"section"},{"location":"guide/direct_api/#Parameter-Tuning","page":"Direct API","title":"Parameter Tuning","text":"","category":"section"},{"location":"guide/direct_api/#Convergence-Tolerance","page":"Direct API","title":"Convergence Tolerance","text":"params = HPRLP_parameters()\n\n# Quick approximate solution\nparams.stoptol = 1e-3\n\n# High accuracy solution\nparams.stoptol = 1e-8\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)","category":"section"},{"location":"guide/direct_api/#Scaling-Options","page":"Direct API","title":"Scaling Options","text":"params = HPRLP_parameters()\n\n# Disable all scaling (if data is already well-scaled)\nparams.use_Ruiz_scaling = false\nparams.use_Pock_Chambolle_scaling = false\nparams.use_bc_scaling = false\n\n# Or enable all (default, recommended)\nparams.use_Ruiz_scaling = true\nparams.use_Pock_Chambolle_scaling = true\nparams.use_bc_scaling = true","category":"section"},{"location":"guide/direct_api/#Iteration-and-Time-Limits","page":"Direct API","title":"Iteration and Time Limits","text":"params = HPRLP_parameters()\nparams.max_iter = 100000       # Maximum iterations\nparams.time_limit = 1800       # 30 minutes\nparams.check_iter = 100        # Check convergence every 100 iterations","category":"section"},{"location":"guide/direct_api/#Accessing-Solution-Information","page":"Direct API","title":"Accessing Solution Information","text":"result = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\n# Optimization status\nif result.output_type == \"OPTIMAL\"\n    println(\"Found optimal solution!\")\n    \n    # Objective value\n    obj = result.primal_obj\n    \n    # Primal solution\n    x = result.x\n    \n    # Dual solutions\n    y = result.y  # Constraint duals\n    z = result.z  # Variable bound duals\n    \n    # Performance metrics\n    println(\"Iterations: \", result.iter)\n    println(\"Time: \", result.time, \" seconds\")\n    println(\"Residuals: \", result.residuals)\n    println(\"Gap: \", result.gap)\n    \nelseif result.output_type == \"TIME_LIMIT\"\n    println(\"Time limit reached\")\n    println(\"Best objective found: \", result.primal_obj)\n    \nelseif result.output_type == \"MAX_ITER\"\n    println(\"Iteration limit reached\")\n    println(\"Current objective: \", result.primal_obj)\nend","category":"section"},{"location":"guide/direct_api/#Accuracy-Tracking","page":"Direct API","title":"Accuracy Tracking","text":"The solver tracks when different accuracy levels are reached:\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"Time to 1e-4 accuracy: \", result.time_4, \" seconds\")\nprintln(\"Iterations to 1e-4: \", result.iter_4)\n\nprintln(\"Time to 1e-6 accuracy: \", result.time_6, \" seconds\")\nprintln(\"Iterations to 1e-6: \", result.iter_6)\n\nprintln(\"Time to 1e-8 accuracy: \", result.time_8, \" seconds\")\nprintln(\"Iterations to 1e-8: \", result.iter_8)","category":"section"},{"location":"guide/direct_api/#Silent-Mode","page":"Direct API","title":"Silent Mode","text":"Suppress all output:\n\nparams = HPRLP_parameters()\nparams.verbose = false\nparams.warm_up = false\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n# No output, only returns result","category":"section"},{"location":"guide/direct_api/#Example:-Portfolio-Optimization","page":"Direct API","title":"Example: Portfolio Optimization","text":"using HPRLP\nusing SparseArrays\n\n# Simple portfolio optimization\n# min -μᵀw (negative expected return)\n# s.t. Σᵢ wᵢ = 1  (fully invested)\n#      wᵢ ≥ 0    (long-only)\n#      wᵢ ≤ 0.2  (max 20% per asset)\n\nn_assets = 100\nexpected_returns = rand(n_assets) .* 0.1  # 0-10% expected return\n\n# Constraints: sum(w) = 1\nA = sparse(ones(1, n_assets))\nAL = [1.0]\nAU = [1.0]\n\n# Objective: minimize -μᵀw (i.e., maximize μᵀw)\nc = -expected_returns\n\n# Variable bounds: 0 ≤ w ≤ 0.2\nl = zeros(n_assets)\nu = 0.2 * ones(n_assets)\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = false\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"Expected portfolio return: \", -result.primal_obj)\nprintln(\"Weights: \", result.x)\nprintln(\"Number of positions: \", count(result.x .> 1e-6))","category":"section"},{"location":"guide/mps_files/#Solving-MPS-Files","page":"MPS Files","title":"Solving MPS Files","text":"HPRLP can directly read and solve linear programming problems in MPS (Mathematical Programming System) format, a widely-used industry standard format.","category":"section"},{"location":"guide/mps_files/#Quick-Start","page":"MPS Files","title":"Quick Start","text":"using HPRLP\n\n# Configure solver parameters\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.stoptol = 1e-4\nparams.verbose = true\n\n# Solve MPS file\nresult = run_single(\"path/to/problem.mps\", params)\n\n# Access results\nprintln(\"Objective value: \", result.primal_obj)\nprintln(\"Status: \", result.output_type)\nprintln(\"Solve time: \", result.time, \" seconds\")","category":"section"},{"location":"guide/mps_files/#MPS-Format-Overview","page":"MPS Files","title":"MPS Format Overview","text":"The MPS format defines an LP problem with these sections:\n\nNAME: Problem name\nROWS: Constraint types (N=objective, E=equality, L=≤, G=≥)\nCOLUMNS: Nonzero entries in constraint matrix\nRHS: Right-hand side values\nBOUNDS: Variable bounds\nENDATA: End marker","category":"section"},{"location":"guide/mps_files/#Example-MPS-File","page":"MPS Files","title":"Example MPS File","text":"NAME          EXAMPLE\nROWS\n N  OBJ\n L  ROW1\n L  ROW2\nCOLUMNS\n    X1        ROW1      1.0\n    X1        ROW2      3.0\n    X1        OBJ      -3.0\n    X2        ROW1      2.0\n    X2        ROW2      1.0\n    X2        OBJ      -5.0\nRHS\n    RHS1      ROW1     10.0\n    RHS1      ROW2     12.0\nBOUNDS\n LO BND1      X1        0.0\n LO BND1      X2        0.0\nENDATA\n\nThis represents:\n\nbeginarrayll\nmin quad  -3x_1 - 5x_2 \ntextst quad  x_1 + 2x_2 leq 10 \n 3x_1 + x_2 leq 12 \n x_1 x_2 geq 0\nendarray","category":"section"},{"location":"guide/mps_files/#Working-with-MPS-Files","page":"MPS Files","title":"Working with MPS Files","text":"","category":"section"},{"location":"guide/mps_files/#Basic-Usage","page":"MPS Files","title":"Basic Usage","text":"using HPRLP\n\n# Simple solve with defaults\nparams = HPRLP_parameters()\nresult = run_single(\"model.mps\", params)\n\nif result.output_type == \"OPTIMAL\"\n    println(\"Found optimal solution!\")\n    println(\"Objective: \", result.primal_obj)\n    println(\"Solution vector: \", result.x)\nelse\n    println(\"Solver stopped with status: \", result.output_type)\nend","category":"section"},{"location":"guide/mps_files/#With-Custom-Parameters","page":"MPS Files","title":"With Custom Parameters","text":"params = HPRLP_parameters()\n\n# Solver settings\nparams.stoptol = 1e-6          # Higher accuracy\nparams.time_limit = 7200       # 2 hour time limit\nparams.max_iter = 1000000      # Maximum iterations\n\n# Performance settings\nparams.use_gpu = true          # Enable GPU\nparams.device_number = 0       # Use first GPU\n\n# Scaling options\nparams.use_Ruiz_scaling = true\nparams.use_Pock_Chambolle_scaling = true\nparams.use_bc_scaling = true\n\n# Output control\nparams.verbose = true          # Show progress\nparams.print_frequency = 100   # Print every 100 iterations\n\nresult = run_single(\"large_problem.mps\", params)","category":"section"},{"location":"guide/mps_files/#Silent-Mode","page":"MPS Files","title":"Silent Mode","text":"For batch processing or when embedding in larger applications:\n\nparams = HPRLP_parameters()\nparams.verbose = false  # No output\nparams.warm_up = false  # Skip warm-up for speed\n\nresult = run_single(\"problem.mps\", params)","category":"section"},{"location":"guide/mps_files/#Warm-up-Phase","page":"MPS Files","title":"Warm-up Phase","text":"For better performance when solving multiple similar problems:\n\nparams = HPRLP_parameters()\nparams.warm_up = true  # Enable warm-up (default)\n\n# First call: includes warm-up compilation\nresult1 = run_single(\"problem1.mps\", params)\n\n# Subsequent calls: already compiled, faster\nresult2 = run_single(\"problem2.mps\", params)\nresult3 = run_single(\"problem3.mps\", params)","category":"section"},{"location":"guide/mps_files/#Batch-Processing","page":"MPS Files","title":"Batch Processing","text":"Process multiple MPS files:\n\nusing HPRLP\n\nfunction solve_batch(files::Vector{String}, params::HPRLP_parameters)\n    results = Dict{String, HprLP_results}()\n    \n    for (i, file) in enumerate(files)\n        println(\"Solving $i/$(length(files)): $file\")\n        \n        try\n            result = run_single(file, params)\n            results[file] = result\n            \n            println(\"  Status: $(result.output_type)\")\n            println(\"  Objective: $(result.primal_obj)\")\n            println(\"  Time: $(result.time)s\")\n        catch e\n            println(\"  ERROR: $e\")\n        end\n    end\n    \n    return results\nend\n\n# Usage\nparams = HPRLP_parameters()\nparams.verbose = false\nparams.time_limit = 600  # 10 minutes per problem\n\nfiles = [\"problem1.mps\", \"problem2.mps\", \"problem3.mps\"]\nresults = solve_batch(files, params)","category":"section"},{"location":"guide/mps_files/#Checking-Problem-Statistics","page":"MPS Files","title":"Checking Problem Statistics","text":"The solver prints problem information when verbose = true:\n\nREADING FILE ... problem.mps\nREADING FILE time: 0.15 seconds\nFORMULATING LP ...\nproblem information: nRow = 1000, nCol = 2000, nnz A = 10000\n                     number of equalities = 100\n                     number of inequalities = 900\nFORMULATING LP time: 0.05 seconds","category":"section"},{"location":"guide/mps_files/#Common-MPS-Sources","page":"MPS Files","title":"Common MPS Sources","text":"","category":"section"},{"location":"guide/mps_files/#NETLIB","page":"MPS Files","title":"NETLIB","text":"The classic NETLIB LP test set:\n\nDownload from: http://www.netlib.org/lp/data/\nContains problems of various sizes and characteristics\nStandard benchmark for LP solvers","category":"section"},{"location":"guide/mps_files/#MIPLIB","page":"MPS Files","title":"MIPLIB","text":"Mixed-Integer Programming Library (LP relaxations):\n\nDownload from: https://miplib.zib.de/\nIncludes continuous LP problems\nChallenging real-world instances","category":"section"},{"location":"guide/mps_files/#Hans-Mittelmann's-Benchmark","page":"MPS Files","title":"Hans Mittelmann's Benchmark","text":"Collection of LP and optimization problems:\n\nhttp://plato.asu.edu/ftp/lptestset/\nRegularly updated\nVarious problem classes","category":"section"},{"location":"guide/mps_files/#Performance-Tips","page":"MPS Files","title":"Performance Tips","text":"GPU vs CPU: \nUse GPU for large problems (> 10,000 variables/constraints)\nUse CPU for small to medium problems or when GPU is unavailable\nTolerance:\nDefault stoptol = 1e-4 is good for most applications\nUse 1e-6 or 1e-8 for high-accuracy requirements\nLower tolerances significantly increase solve time\nTime Limits:\nSet reasonable time limits for batch processing\nDefault is 3600 seconds (1 hour)\nScaling:\nKeep scaling enabled for better numerical stability\nDisable only if you have pre-scaled data","category":"section"},{"location":"guide/mps_files/#Troubleshooting","page":"MPS Files","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/mps_files/#File-Not-Found","page":"MPS Files","title":"File Not Found","text":"# Check file path\nif !isfile(\"problem.mps\")\n    error(\"File not found!\")\nend\n\nresult = run_single(\"problem.mps\", params)","category":"section"},{"location":"guide/mps_files/#Time-Limit-Reached","page":"MPS Files","title":"Time Limit Reached","text":"result = run_single(\"problem.mps\", params)\n\nif result.output_type == \"TIME_LIMIT\"\n    println(\"Time limit reached after $(result.time) seconds\")\n    println(\"Current objective: $(result.primal_obj)\")\n    println(\"Residuals: $(result.residuals)\")\n    \n    # Could increase time limit and retry\n    params.time_limit = 7200\n    result = run_single(\"problem.mps\", params)\nend","category":"section"},{"location":"guide/mps_files/#Iteration-Limit","page":"MPS Files","title":"Iteration Limit","text":"if result.output_type == \"MAX_ITER\"\n    println(\"Maximum iterations reached\")\n    println(\"Increase max_iter or check problem formulation\")\nend","category":"section"},{"location":"#HPRLP.jl-Documentation","page":"Home","title":"HPRLP.jl Documentation","text":"A GPU-accelerated Julia package for solving Linear Programming problems using the Halpern Peaceman-Rachford (HPR) method.","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"HPRLP.jl is a high-performance linear programming solver that leverages GPU acceleration to solve large-scale LP problems efficiently. It implements the Halpern Peaceman-Rachford splitting method with adaptive restart strategies.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"✅ GPU Acceleration: Native CUDA support for solving large-scale problems\n✅ CPU Fallback: Automatic CPU mode when GPU is not available\n✅ Multiple Interfaces: \nDirect API with matrix inputs\nMPS file format support\nJuMP integration via MOI wrapper\n✅ Flexible Scaling: Ruiz and Pock-Chambolle scaling methods\n✅ Adaptive Algorithms: Automatic restart strategies and step-size selection\n✅ Silent Mode: Control output verbosity for embedding in larger applications","category":"section"},{"location":"#Problem-Formulation","page":"Home","title":"Problem Formulation","text":"HPRLP solves linear programming problems of the form:\n\nbeginarrayll\nmin_x in mathbbR^n quad  langle c x rangle \ntextsubject to quad  L leq A x leq U \n l leq x leq u\nendarray\n\nwhere:\n\nx in mathbbR^n is the decision variable\nc in mathbbR^n is the objective coefficient vector\nA in mathbbR^m times n is the constraint matrix\nL U in mathbbR^m are lower and upper bounds on constraints\nl u in mathbbR^n are lower and upper bounds on variables","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"HPRLP\")  # Once registered\n\nOr from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/PolyU-IOR/HPR-LP\")","category":"section"},{"location":"#Simple-Example","page":"Home","title":"Simple Example","text":"using HPRLP\nusing SparseArrays\n\n# Define LP: min -3x₁ - 5x₂ s.t. x₁ + 2x₂ ≤ 10, 3x₁ + x₂ ≤ 12, x ≥ 0\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\nparams = HPRLP_parameters()\nparams.use_gpu = false  # Use CPU\nparams.verbose = false  # Silent mode\n\nresult = run_lp(A, AL, AU, c, l, u, 0.0, params)\n\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: x = \", result.x)","category":"section"},{"location":"#With-JuMP","page":"Home","title":"With JuMP","text":"using JuMP, HPRLP\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)  # Optional: suppress output\n\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, x1 + 2x2 <= 10)\n@constraint(model, 3x1 + x2 <= 12)\n\noptimize!(model)\nprintln(\"Objective: \", objective_value(model))\nprintln(\"x1 = \", value(x1), \", x2 = \", value(x2))","category":"section"},{"location":"#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/mps_files.md\",\n    \"guide/direct_api.md\",\n    \"guide/jump_integration.md\",\n    \"api.md\",\n    \"examples.md\",\n]\nDepth = 2","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use HPRLP in your research, please cite:\n\n@article{chen2025hprlp,\n  title={HPR-LP: An implementation of an HPR method for solving linear programming},\n  author={Chen, Kaihuang and Sun, Defeng and Yuan, Yancheng and Zhang, Guojun and Zhao, Xinyuan},\n  journal={Mathematical Programming Computation},\n  volume={17},\n  year={2025},\n  doi={10.1007/s12532-025-00292-0}\n}","category":"section"},{"location":"#License","page":"Home","title":"License","text":"HPRLP.jl is licensed under the MIT License. See LICENSE for details.","category":"section"}]
}
