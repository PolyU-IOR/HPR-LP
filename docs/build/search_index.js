var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"Complete API documentation for HPRLP. For detailed guides, see:\n\nParameters Guide - Detailed parameter explanations\nOutput & Results - Understanding solver output","category":"section"},{"location":"api.html#Main-Functions","page":"API Reference","title":"Main Functions","text":"","category":"section"},{"location":"api.html#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"api.html#Quick-Reference","page":"API Reference","title":"Quick Reference","text":"","category":"section"},{"location":"api.html#Solving-Problems","page":"API Reference","title":"Solving Problems","text":"Direct API (Matrix Form):\n\n# Step 1: Build the model\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\n# Step 2: Set parameters\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\n\n# Step 3: Optimize\nresult = optimize(model, params)\n\nMPS Files:\n\n# Step 1: Build the model from file\nmodel = build_from_mps(\"problem.mps\")\n\n# Step 2: Set parameters\nparams = HPRLP_parameters()\n\n# Step 3: Optimize\nresult = optimize(model, params)\n\nJuMP:\n\nmodel = Model(HPRLP.Optimizer)\n# ... add variables and constraints ...\noptimize!(model)","category":"section"},{"location":"api.html#Common-Parameter-Settings","page":"API Reference","title":"Common Parameter Settings","text":"params = HPRLP_parameters()\nparams.stoptol = 1e-6           # Convergence tolerance\nparams.use_gpu = true           # Enable GPU\nparams.verbose = false          # Silent mode\nparams.time_limit = 3600        # Time limit (seconds)\nparams.warm_up = true           # Enable warmup for accurate timing\nparams.initial_x = x0           # Initial primal solution\nparams.initial_y = y0           # Initial dual solution\nparams.auto_save = true         # Auto-save best solution\nparams.save_filename = \"opt.h5\" # HDF5 file for auto-save","category":"section"},{"location":"api.html#Accessing-Results","page":"API Reference","title":"Accessing Results","text":"result.status         # \"OPTIMAL\", \"MAX_ITER\", or \"TIME_LIMIT\"\nresult.primal_obj     # Primal objective value\nresult.x              # Primal solution vector\nresult.y              # Dual solution vector (constraints)\nresult.z              # Dual solution vector (bounds)\nresult.iter           # Total iterations\nresult.time           # Solve time (seconds)\nresult.residuals      # Final residual (max of primal, dual, gap)","category":"section"},{"location":"api.html#See-Also","page":"API Reference","title":"See Also","text":"User Guide - Comprehensive usage guides\nExamples - Complete working examples","category":"section"},{"location":"api.html#HPRLP.build_from_mps","page":"API Reference","title":"HPRLP.build_from_mps","text":"build_from_mps(filename; verbose=true)\n\nBuild an LP model from an MPS file.\n\nArguments\n\nfilename::String: Path to the .mps file\nverbose::Bool: Enable verbose output (default: true)\n\nReturns\n\nLP_info_cpu: LP model ready to be solved\n\nExample\n\nusing HPRLP\n\nmodel = build_from_mps(\"problem.mps\")\nparams = HPRLP_parameters()\nresult = optimize(model, params)\n\nSee also: build_from_Abc, optimize\n\n\n\n\n\n","category":"function"},{"location":"api.html#HPRLP.build_from_Abc","page":"API Reference","title":"HPRLP.build_from_Abc","text":"build_from_Abc(A, c, AL, AU, l, u, obj_constant=0.0)\n\nBuild an LP model from matrix form.\n\nArguments\n\nA::Union{SparseMatrixCSC, Matrix}: Constraint matrix (m × n). Dense matrices will be automatically converted to sparse format with a warning.\nc::Vector{Float64}: Objective coefficients (length n)\nAL::Vector{Float64}: Lower bounds for constraints Ax (length m)\nAU::Vector{Float64}: Upper bounds for constraints Ax (length m)\nl::Vector{Float64}: Lower bounds for variables x (length n)\nu::Vector{Float64}: Upper bounds for variables x (length n)\nobj_constant::Float64: Constant term in objective function (default: 0.0)\n\nReturns\n\nLP_info_cpu: LP model ready to be solved\n\nExample\n\nusing SparseArrays, HPRLP\n\nA = sparse([1.0 2.0; 3.0 1.0])\nc = [-3.0, -5.0]\nAL = [-Inf, -Inf]\nAU = [10.0, 12.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\nmodel = build_from_Abc(A, c, AL, AU, l, u)\nparams = HPRLP_parameters()\nresult = optimize(model, params)\n\nSee also: build_from_mps, optimize\n\n\n\n\n\n","category":"function"},{"location":"api.html#HPRLP.optimize","page":"API Reference","title":"HPRLP.optimize","text":"optimize(model::LP_info_cpu, params::HPRLP_parameters)\n\nOptimize a linear program using the HPR-LP algorithm.\n\nThis function handles GPU transfer, scaling, and optional warmup internally based on the parameters.\n\nArguments\n\nmodel::LP_info_cpu: LP model built from build_from_mps or build_from_Abc\nparams::HPRLP_parameters: Solver parameters\n\nReturns\n\nHPRLP_results: Solution results including objective value, solution vector, and convergence info\n\nExample\n\nusing HPRLP\n\nmodel = build_from_mps(\"problem.mps\")\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\nparams.use_gpu = true\nparams.warm_up = true\n\nresult = optimize(model, params)\nprintln(\"Status: \", result.status)\nprintln(\"Objective: \", result.primal_obj)\n\nSee also: build_from_mps, build_from_Abc, HPRLP_parameters\n\n\n\n\n\n","category":"function"},{"location":"api.html#HPRLP.Optimizer","page":"API Reference","title":"HPRLP.Optimizer","text":"Optimizer()\n\nCreate a new HPRLP Optimizer object.\n\nSet optimizer attributes using MOI.RawOptimizerAttribute or JuMP.set_optimizer_attribute.\n\nExample\n\nusing JuMP, HPRLP\nmodel = JuMP.Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\nset_optimizer_attribute(model, \"use_gpu\", true)\n\n\n\n\n\n","category":"type"},{"location":"api.html#HPRLP.HPRLP_parameters","page":"API Reference","title":"HPRLP.HPRLP_parameters","text":"HPRLP_parameters\n\nParameters for the HPR-LP solver.\n\nFields\n\nstoptol::Float64: Stopping tolerance (default: 1e-4)\nmax_iter::Int: Maximum number of iterations (default: typemax(Int32))\ntime_limit::Float64: Time limit in seconds (default: 3600.0)\ncheck_iter::Int: Interval for residual checks (default: 150)\nuse_Ruiz_scaling::Bool: Enable Ruiz scaling (default: true)\nuse_Pock_Chambolle_scaling::Bool: Enable Pock-Chambolle scaling (default: true)\nuse_bc_scaling::Bool: Enable b/c scaling (default: true)\nuse_gpu::Bool: Use GPU acceleration (default: true)\ndevice_number::Int: GPU device number (default: 0)\nwarm_up::Bool: Enable warm-up phase (default: true)\nprint_frequency::Int: Print log every N iterations, -1 for auto (default: -1)\nverbose::Bool: Enable verbose output (default: true)\ninitial_x::Union{Vector{Float64},Nothing}: Initial primal solution (default: nothing)\ninitial_y::Union{Vector{Float64},Nothing}: Initial dual solution (default: nothing)\nauto_save::Bool: Automatically save best x, y, and sigma during optimization (default: false)\nsave_filename::String: Filename for auto-save HDF5 file (default: \"hprlp_autosave.h5\")\n\nExample\n\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\nparams.use_gpu = false\nparams.verbose = false\nparams.auto_save = true\nparams.save_filename = \"my_optimization.h5\"\n# Provide initial point\nparams.initial_x = x0\nparams.initial_y = y0\n\n\n\n\n\n","category":"type"},{"location":"api.html#HPRLP.HPRLP_results","page":"API Reference","title":"HPRLP.HPRLP_results","text":"HPRLP_results\n\nResults from the HPR-LP solver.\n\nFields\n\niter::Int: Total number of iterations\niter_4::Int: Iterations to reach 1e-4 accuracy\niter_6::Int: Iterations to reach 1e-6 accuracy\niter_8::Int: Iterations to reach 1e-8 accuracy\ntime::Float64: Total solve time in seconds\ntime_4::Float64: Time to reach 1e-4 accuracy\ntime_6::Float64: Time to reach 1e-6 accuracy\ntime_8::Float64: Time to reach 1e-8 accuracy\nprimal_obj::Float64: Primal objective value\ndual_obj::Float64: Dual objective value\nprimal_residual::Float64: Final primal feasibility residual\ndual_residual::Float64: Final dual feasibility residual\nrelative_duality_gap::Float64: Final relative duality gap\nx::Vector{Float64}: Primal solution vector\nstatus::String: Termination status (\"Optimal\", \"TimeLimit\", \"IterationLimit\")\n\nExample\n\nmodel = build_from_mps(\"problem.mps\")\nparams = HPRLP_parameters()\nresults = solve(model, params)\nprintln(\"Status: \", results.status)\nprintln(\"Objective: \", results.primal_obj)\nprintln(\"Time: \", results.time, \" seconds\")\n\n\n\n\n\n","category":"type"},{"location":"guide/jump_integration.html#JuMP-Integration","page":"JuMP Integration","title":"JuMP Integration","text":"HPRLP integrates seamlessly with JuMP through the MathOptInterface (MOI), allowing you to use HPRLP as a backend solver for JuMP models.","category":"section"},{"location":"guide/jump_integration.html#Basic-Usage","page":"JuMP Integration","title":"Basic Usage","text":"using JuMP\nusing HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@objective(model, Min, -3x - 5y)\n@constraint(model, x + 2y <= 10)\n@constraint(model, 3x + y <= 12)\n\noptimize!(model)\n\nprintln(\"Optimal value: \", objective_value(model))\nprintln(\"x = \", value(x), \", y = \", value(y))","category":"section"},{"location":"guide/jump_integration.html#Setting-Solver-Attributes","page":"JuMP Integration","title":"Setting Solver Attributes","text":"","category":"section"},{"location":"guide/jump_integration.html#Using-set_optimizer_attribute","page":"JuMP Integration","title":"Using set_optimizer_attribute","text":"model = Model(HPRLP.Optimizer)\n\n# Standard MOI attributes\nset_silent(model)                      # Suppress output\nset_time_limit_sec(model, 3600.0)     # 1 hour time limit\n\n# HPRLP-specific attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-6)\nset_optimizer_attribute(model, \"use_gpu\", true)\nset_optimizer_attribute(model, \"device_number\", 0)\nset_optimizer_attribute(model, \"use_Ruiz_scaling\", true)\nset_optimizer_attribute(model, \"warm_up\", true)\nset_optimizer_attribute(model, \"max_iter\", 100000)\n\n# New features: warm-start and auto-save\nset_optimizer_attribute(model, \"initial_x\", x0)  # Warm-start primal\nset_optimizer_attribute(model, \"initial_y\", y0)  # Warm-start dual\nset_optimizer_attribute(model, \"auto_save\", true)\nset_optimizer_attribute(model, \"save_filename\", \"optimization.h5\")\n\ntip: Parameter Reference\nFor detailed explanations of all parameters, see the Parameters guide.","category":"section"},{"location":"guide/jump_integration.html#Querying-Results","page":"JuMP Integration","title":"Querying Results","text":"","category":"section"},{"location":"guide/jump_integration.html#Termination-Status","page":"JuMP Integration","title":"Termination Status","text":"optimize!(model)\n\nstatus = termination_status(model)\n\nif status == MOI.OPTIMAL\n    println(\"Optimal solution found!\")\nelseif status == MOI.TIME_LIMIT\n    println(\"Time limit reached\")\nelseif status == MOI.ITERATION_LIMIT\n    println(\"Iteration limit reached\")\nend","category":"section"},{"location":"guide/jump_integration.html#Objective-and-Solutions","page":"JuMP Integration","title":"Objective and Solutions","text":"if has_values(model)\n    obj_val = objective_value(model)\n    x_val = value(x)\n    y_val = value(y)\n    \n    println(\"Objective: $obj_val\")\n    println(\"x = $x_val, y = $y_val\")\nend","category":"section"},{"location":"guide/jump_integration.html#Solve-Time","page":"JuMP Integration","title":"Solve Time","text":"time = solve_time(model)\nprintln(\"Solved in $time seconds\")","category":"section"},{"location":"guide/jump_integration.html#Silent-Mode","page":"JuMP Integration","title":"Silent Mode","text":"Suppress all solver output:\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n# Build model...\noptimize!(model)\n# No output from solver\n\nOr equivalently:\n\nmodel = Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"verbose\", false)\noptimize!(model)","category":"section"},{"location":"guide/jump_integration.html#Common-Patterns","page":"JuMP Integration","title":"Common Patterns","text":"","category":"section"},{"location":"guide/jump_integration.html#Production-Portfolio","page":"JuMP Integration","title":"Production Portfolio","text":"using JuMP, HPRLP\n\n# Production planning\nproducts = 1:5\nresources = 1:3\n\nprofit = rand(5) .* 10\nresource_usage = rand(3, 5)\nresource_capacity = rand(3) .* 100\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, production[products] >= 0)\n@objective(model, Max, sum(profit[p] * production[p] for p in products))\n\nfor r in resources\n    @constraint(model, \n        sum(resource_usage[r,p] * production[p] for p in products) \n        <= resource_capacity[r]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    println(\"Optimal profit: \", objective_value(model))\n    for p in products\n        println(\"Product $p: \", value(production[p]))\n    end\nend","category":"section"},{"location":"guide/jump_integration.html#Network-Flow","page":"JuMP Integration","title":"Network Flow","text":"using JuMP, HPRLP\n\n# Simple network flow\nnodes = 1:5\narcs = [(1,2), (1,3), (2,4), (3,4), (4,5)]\ncapacity = Dict(arcs .=> rand(length(arcs)) .* 10)\nsupply = [10.0, 0, 0, 0, -10]  # Source at 1, sink at 5\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, 0 <= flow[a in arcs] <= capacity[a])\n@objective(model, Min, sum(flow[a] for a in arcs))  # Min total flow\n\n# Flow conservation\nfor n in nodes\n    incoming = [a for a in arcs if a[2] == n]\n    outgoing = [a for a in arcs if a[1] == n]\n    \n    @constraint(model,\n        sum(flow[a] for a in incoming) - \n        sum(flow[a] for a in outgoing) == -supply[n]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    for a in arcs\n        if value(flow[a]) > 1e-6\n            println(\"Arc $a: \", value(flow[a]))\n        end\n    end\nend","category":"section"},{"location":"guide/jump_integration.html#Diet-Problem","page":"JuMP Integration","title":"Diet Problem","text":"using JuMP, HPRLP\n\n# Classic diet problem\nfoods = [\"Bread\", \"Milk\", \"Eggs\", \"Meat\", \"Cake\"]\nnutrients = [\"Calories\", \"Protein\", \"Fat\"]\n\ncost = [2.0, 3.5, 2.5, 8.0, 5.0]\nnutrition = [\n    300 200 100 400 500;  # Calories\n     10  15  12  30   5;  # Protein (g)\n      5  10   8  20  15   # Fat (g)\n]\nmin_nutrient = [2000, 50, 30]  # Daily requirements\n\nmodel = Model(HPRLP.Optimizer)\nset_silent(model)\n\n@variable(model, servings[1:5] >= 0)\n@objective(model, Min, sum(cost[i] * servings[i] for i in 1:5))\n\nfor n in 1:3\n    @constraint(model,\n        sum(nutrition[n,f] * servings[f] for f in 1:5) >= min_nutrient[n]\n    )\nend\n\noptimize!(model)\n\nif termination_status(model) == MOI.OPTIMAL\n    println(\"Minimum cost: \\$\", objective_value(model))\n    for (i, food) in enumerate(foods)\n        if value(servings[i]) > 1e-6\n            println(\"$food: \", value(servings[i]), \" servings\")\n        end\n    end\nend","category":"section"},{"location":"guide/jump_integration.html#Reading-MPS-Files-with-JuMP","page":"JuMP Integration","title":"Reading MPS Files with JuMP","text":"You can read MPS files and solve them with HPRLP via JuMP:\n\nusing JuMP, HPRLP\n\nmodel = read_from_file(\"problem.mps\")\nset_optimizer(model, HPRLP.Optimizer)\n\n# Set attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-6)\n\n# Solve\noptimize!(model)\n\nprintln(\"Status: \", termination_status(model))\nif has_values(model)\n    println(\"Objective: \", objective_value(model))\nend","category":"section"},{"location":"guide/jump_integration.html#Comparison-with-Other-Solvers","page":"JuMP Integration","title":"Comparison with Other Solvers","text":"Easy to switch between solvers:\n\nusing JuMP, HPRLP, HiGHS\n\n# Build model\nfunction build_model()\n    model = Model()\n    @variable(model, x >= 0)\n    @variable(model, y >= 0)\n    @objective(model, Min, -3x - 5y)\n    @constraint(model, x + 2y <= 10)\n    @constraint(model, 3x + y <= 12)\n    return model\nend\n\n# Solve with HPRLP\nmodel1 = build_model()\nset_optimizer(model1, HPRLP.Optimizer)\noptimize!(model1)\nprintln(\"HPRLP: \", objective_value(model1))\n\n# Solve with HiGHS\nmodel2 = build_model()\nset_optimizer(model2, HiGHS.Optimizer)\noptimize!(model2)\nprintln(\"HiGHS: \", objective_value(model2))","category":"section"},{"location":"guide/jump_integration.html#Performance-Tips","page":"JuMP Integration","title":"Performance Tips","text":"Set silent mode for faster execution in production\nDisable warm-up if solving many small problems\nUse GPU for problems with > 10,000 variables\nAdjust tolerance based on application needs\nReuse models when solving similar problems repeatedly","category":"section"},{"location":"guide/jump_integration.html#Troubleshooting","page":"JuMP Integration","title":"Troubleshooting","text":"","category":"section"},{"location":"guide/jump_integration.html#Slow-First-Run","page":"JuMP Integration","title":"Slow First Run","text":"Julia's JIT compilation causes slow first runs. Use warm-up:\n\nset_optimizer_attribute(model, \"warm_up\", true)  # Default","category":"section"},{"location":"guide/jump_integration.html#See-Also","page":"JuMP Integration","title":"See Also","text":"Parameters - Complete guide to all solver parameters and their effects\nOutput & Results - Understanding solver output and solution quality","category":"section"},{"location":"guide/output_results.html#Output-and-Results","page":"Output & Results","title":"Output & Results","text":"This guide explains how to interpret the results returned by HPRLP solvers and understand the termination status.","category":"section"},{"location":"guide/output_results.html#Result-Fields-Summary","page":"Output & Results","title":"Result Fields Summary","text":"All HPRLP solving functions return an HPRLP_results object with the following fields:\n\nField Type Description\nstatus String Termination status: \"OPTIMAL\", \"MAX_ITER\", or \"TIME_LIMIT\"\nx Vector{Float64} Primal solution (decision variables)\ny Vector{Float64} Dual variables for constraints\nz Vector{Float64} Dual variables for bounds\nprimal_obj Float64 Primal objective value (c^T x + c_0)\niter Int Total number of iterations\ntime Float64 Total solve time (seconds)\niter_4, time_4 Int, Float64 Iterations/time to reach 1e-4 accuracy\niter_6, time_6 Int, Float64 Iterations/time to reach 1e-6 accuracy\niter_8, time_8 Int, Float64 Iterations/time to reach 1e-8 accuracy\nresiduals Float64 Combined measure of constraint violations and objective gap\ngap Float64 Objective gap between primal and dual","category":"section"},{"location":"guide/output_results.html#Basic-Usage","page":"Output & Results","title":"Basic Usage","text":"result = run_lp(A, AL, AU, c, l, u, c0, params)\n\n# Access results\nprintln(\"Status: \", result.status)\nprintln(\"Objective: \", result.primal_obj)\nprintln(\"Solution: \", result.x)\nprintln(\"Time: \", result.time, \" seconds\")","category":"section"},{"location":"guide/output_results.html#Result-Fields","page":"Output & Results","title":"Result Fields","text":"","category":"section"},{"location":"guide/output_results.html#Termination-Status","page":"Output & Results","title":"Termination Status","text":"","category":"section"},{"location":"guide/output_results.html#status::String","page":"Output & Results","title":"status::String","text":"Indicates why the solver stopped:\n\n\"OPTIMAL\" - Successfully found an optimal solution within tolerance\n\"MAX_ITER\" - Reached maximum iteration limit before converging\n\"TIME_LIMIT\" - Reached time limit before converging\n\nif result.status == \"OPTIMAL\"\n    println(\"✓ Optimal solution found!\")\n    println(\"Objective value: \", result.primal_obj)\nelseif result.status == \"MAX_ITER\"\n    println(\"⚠ Iteration limit reached\")\n    println(\"Best objective: \", result.primal_obj)\n    println(\"Residual: \", result.residuals)\nelseif result.status == \"TIME_LIMIT\"\n    println(\"⚠ Time limit reached\")\n    println(\"Best objective: \", result.primal_obj)\nend","category":"section"},{"location":"guide/output_results.html#Solution-Vectors","page":"Output & Results","title":"Solution Vectors","text":"","category":"section"},{"location":"guide/output_results.html#x::Vector{Float64}","page":"Output & Results","title":"x::Vector{Float64}","text":"The primal solution vector (decision variables).\n\n# Access solution values\nprintln(\"x₁ = \", result.x[1])\nprintln(\"x₂ = \", result.x[2])\n\n# Use in calculations\noptimal_cost = sum(c .* result.x)","category":"section"},{"location":"guide/output_results.html#y::Vector{Float64}","page":"Output & Results","title":"y::Vector{Float64}","text":"The dual variables for constraints.","category":"section"},{"location":"guide/output_results.html#z::Vector{Float64}","page":"Output & Results","title":"z::Vector{Float64}","text":"The dual variables for bound constraints (reduced costs).","category":"section"},{"location":"guide/output_results.html#Objective-Values","page":"Output & Results","title":"Objective Values","text":"","category":"section"},{"location":"guide/output_results.html#primal_obj::Float64","page":"Output & Results","title":"primal_obj::Float64","text":"The primal objective value: c^T x + c_0\n\nprintln(\"Optimal cost: \", result.primal_obj)","category":"section"},{"location":"guide/output_results.html#Performance-Metrics","page":"Output & Results","title":"Performance Metrics","text":"","category":"section"},{"location":"guide/output_results.html#iter::Int","page":"Output & Results","title":"iter::Int","text":"Total number of iterations performed.\n\nprintln(\"Solved in \", result.iter, \" iterations\")","category":"section"},{"location":"guide/output_results.html#time::Float64","page":"Output & Results","title":"time::Float64","text":"Total solve time in seconds (excluding setup and scaling).\n\nprintln(\"Solve time: \", result.time, \" seconds\")","category":"section"},{"location":"guide/output_results.html#Accuracy-Milestones","page":"Output & Results","title":"Accuracy Milestones","text":"HPRLP tracks when certain accuracy levels are reached:\n\niter_4, time_4 - Iterations/time to reach 1e-4 accuracy\niter_6, time_6 - Iterations/time to reach 1e-6 accuracy  \niter_8, time_8 - Iterations/time to reach 1e-8 accuracy\n\nif result.time_6 < params.time_limit\n    println(\"Reached 1e-6 accuracy in \", result.iter_6, \" iterations\")\n    println(\"Time to 1e-6: \", result.time_6, \" seconds\")\nend","category":"section"},{"location":"guide/output_results.html#Quality-Metrics","page":"Output & Results","title":"Quality Metrics","text":"","category":"section"},{"location":"guide/output_results.html#residuals::Float64","page":"Output & Results","title":"residuals::Float64","text":"Combined measure of constraint violations and objective gap. Lower is better.\n\nprintln(\"Final residual: \", result.residuals)","category":"section"},{"location":"guide/output_results.html#gap::Float64","page":"Output & Results","title":"gap::Float64","text":"Objective gap between primal and dual solutions.\n\nprintln(\"Objective gap: \", result.gap)","category":"section"},{"location":"guide/output_results.html#Checking-Solution-Quality","page":"Output & Results","title":"Checking Solution Quality","text":"","category":"section"},{"location":"guide/output_results.html#Optimal-Solutions","page":"Output & Results","title":"Optimal Solutions","text":"function check_solution_quality(result, params)\n    if result.status != \"OPTIMAL\"\n        @warn \"Solution not optimal: $(result.status)\"\n    end\n    \n    if result.residuals > params.stoptol\n        @warn \"Residuals exceed tolerance: $(result.residuals) > $(params.stoptol)\"\n    end\n    \n    if result.gap > 1e-3\n        @warn \"Large objective gap: $(result.gap)\"\n    end\n    \n    return result.status == \"OPTIMAL\" && \n           result.residuals <= params.stoptol\nend","category":"section"},{"location":"guide/output_results.html#Verifying-Feasibility","page":"Output & Results","title":"Verifying Feasibility","text":"function verify_primal_feasibility(result, A, AL, AU, l, u)\n    x = result.x\n    \n    # Check variable bounds\n    if any(x .< l .- 1e-6) || any(x .> u .+ 1e-6)\n        @warn \"Variable bounds violated\"\n        return false\n    end\n    \n    # Check constraint bounds\n    Ax = A * x\n    if any(Ax .< AL .- 1e-6) || any(Ax .> AU .+ 1e-6)\n        @warn \"Constraint bounds violated\"\n        return false\n    end\n    \n    println(\"✓ Solution is feasible\")\n    return true\nend","category":"section"},{"location":"guide/output_results.html#Examples","page":"Output & Results","title":"Examples","text":"","category":"section"},{"location":"guide/output_results.html#Basic-Usage-2","page":"Output & Results","title":"Basic Usage","text":"using HPRLP\n\nparams = HPRLP_parameters()\nresult = run_single(\"problem.mps\", params)\n\nprintln(\"═══════ Solution Summary ═══════\")\nprintln(\"Status:     \", result.status)\nprintln(\"Objective:  \", result.primal_obj)\nprintln(\"Iterations: \", result.iter)\nprintln(\"Time:       \", round(result.time, digits=3), \" sec\")\nprintln(\"Residual:   \", result.residuals)\nprintln(\"════════════════════════════════\")","category":"section"},{"location":"guide/output_results.html#Detailed-Analysis","page":"Output & Results","title":"Detailed Analysis","text":"function analyze_results(result, params)\n    println(\"\\n\" * \"=\"^50)\n    println(\"HPRLP Solution Analysis\")\n    println(\"=\"^50)\n    \n    # Termination status\n    println(\"\\n[Termination]\")\n    println(\"  Status: \", result.status)\n    \n    # Objective information\n    println(\"\\n[Objective]\")\n    println(\"  Primal: \", result.primal_obj)\n    println(\"  Gap:    \", result.gap)\n    \n    # Performance\n    println(\"\\n[Performance]\")\n    println(\"  Iterations: \", result.iter)\n    println(\"  Time:       \", round(result.time, digits=3), \" seconds\")\n    \n    # Accuracy milestones\n    println(\"\\n[Accuracy Milestones]\")\n    if result.iter_4 > 0\n        println(\"  1e-4: \", result.iter_4, \" iterations, \", \n                round(result.time_4, digits=3), \" sec\")\n    end\n    if result.iter_6 > 0\n        println(\"  1e-6: \", result.iter_6, \" iterations, \", \n                round(result.time_6, digits=3), \" sec\")\n    end\n    if result.iter_8 > 0\n        println(\"  1e-8: \", result.iter_8, \" iterations, \", \n                round(result.time_8, digits=3), \" sec\")\n    end\n    \n    # Quality assessment\n    println(\"\\n[Solution Quality]\")\n    println(\"  Residual:  \", result.residuals)\n    println(\"  Tolerance: \", params.stoptol)\n    \n    quality = if result.residuals < params.stoptol / 10\n        \"Excellent\"\n    elseif result.residuals < params.stoptol\n        \"Good\"\n    elseif result.residuals < params.stoptol * 10\n        \"Acceptable\"\n    else\n        \"Poor\"\n    end\n    println(\"  Quality:   \", quality)\n    \n    println(\"=\"^50 * \"\\n\")\nend\n\n# Usage\nresult = run_single(\"model.mps\", params)\nanalyze_results(result, params)","category":"section"},{"location":"guide/output_results.html#Comparing-Solutions","page":"Output & Results","title":"Comparing Solutions","text":"function compare_results(result1, result2, label1=\"Result 1\", label2=\"Result 2\")\n    println(\"\\n\", \"=\"^60)\n    println(\"Solution Comparison\")\n    println(\"=\"^60)\n    \n    println(\"\\n\", rpad(\"Metric\", 20), rpad(label1, 20), label2)\n    println(\"-\"^60)\n    \n    println(rpad(\"Status\", 20), \n            rpad(result1.status, 20), result2.status)\n    println(rpad(\"Objective\", 20), \n            rpad(string(round(result1.primal_obj, digits=6)), 20),\n            round(result2.primal_obj, digits=6))\n    println(rpad(\"Iterations\", 20), \n            rpad(string(result1.iter), 20), result2.iter)\n    println(rpad(\"Time (sec)\", 20), \n            rpad(string(round(result1.time, digits=3)), 20),\n            round(result2.time, digits=3))\n    println(rpad(\"Residual\", 20), \n            rpad(string(result1.residuals), 20), result2.residuals)\n    \n    println(\"=\"^60 * \"\\n\")\nend\n\n# Usage: Compare GPU vs CPU\nparams_gpu = HPRLP_parameters()\nparams_gpu.use_gpu = true\n\nparams_cpu = HPRLP_parameters()\nparams_cpu.use_gpu = false\n\nresult_gpu = run_single(\"model.mps\", params_gpu)\nresult_cpu = run_single(\"model.mps\", params_cpu)\n\ncompare_results(result_gpu, result_cpu, \"GPU\", \"CPU\")","category":"section"},{"location":"guide/output_results.html#Common-Issues","page":"Output & Results","title":"Common Issues","text":"","category":"section"},{"location":"guide/output_results.html#Non-Optimal-Termination","page":"Output & Results","title":"Non-Optimal Termination","text":"If solver stops with MAX_ITER or TIME_LIMIT:\n\nif result.status != \"OPTIMAL\"\n    # Check if close to optimal\n    if result.residuals < 1e-3\n        println(\"Near-optimal solution found\")\n        println(\"Consider increasing time_limit or max_iter\")\n    else\n        println(\"Poor solution quality\")\n        println(\"Problem may be ill-conditioned\")\n        println(\"Try adjusting scaling parameters\")\n    end\nend","category":"section"},{"location":"guide/output_results.html#Large-Residuals","page":"Output & Results","title":"Large Residuals","text":"if result.residuals > params.stoptol * 100\n    @warn \"Very large residuals - possible issues:\"\n    println(\"  - Problem may be infeasible or unbounded\")\n    println(\"  - Numerical scaling issues\")\n    println(\"  - Try enabling all scaling options\")\n    println(\"  - Check problem formulation\")\nend","category":"section"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html#Prerequisites","page":"Getting Started","title":"Prerequisites","text":"Before using HPRLP, ensure you have:\n\nJulia (version 1.10 or higher recommended)\nCUDA (optional, for GPU acceleration)\nCUDA Toolkit 12.4 or higher for best compatibility","category":"section"},{"location":"getting_started.html#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started.html#From-GitHub","page":"Getting Started","title":"From GitHub","text":"using Pkg\nPkg.add(url=\"https://github.com/PolyU-IOR/HPR-LP\")","category":"section"},{"location":"getting_started.html#Development-Installation","page":"Getting Started","title":"Development Installation","text":"To install for development:\n\ngit clone https://github.com/PolyU-IOR/HPR-LP.git\ncd HPR-LP\njulia --project -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"getting_started.html#Verifying-CUDA-Installation","page":"Getting Started","title":"Verifying CUDA Installation","text":"If you plan to use GPU acceleration, verify CUDA is working:\n\nusing CUDA\nCUDA.versioninfo()\n\nIf CUDA is not available, HPRLP will automatically fall back to CPU mode.","category":"section"},{"location":"getting_started.html#First-Example:-Solving-a-Simple-LP","page":"Getting Started","title":"First Example: Solving a Simple LP","text":"Let's solve a basic linear programming problem:\n\nbeginarrayll\nmin quad  -3x_1 - 5x_2 \ntextst quad  x_1 + 2x_2 leq 10 \n 3x_1 + x_2 leq 12 \n x_1 x_2 geq 0\nendarray","category":"section"},{"location":"getting_started.html#Using-the-Direct-API","page":"Getting Started","title":"Using the Direct API","text":"using HPRLP\nusing SparseArrays\n\n# Convert to standard form: AL ≤ Ax ≤ AU\n# Inequality ax + by ≤ c becomes -ax - by ≥ -c (i.e., AL = -c, AU = ∞)\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nc = [-3.0, -5.0]\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\n# Step 1: Build the model\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\n# Step 2: Set up parameters\nparams = HPRLP_parameters()\nparams.use_gpu = false      # Use CPU for this small problem\nparams.stoptol = 1e-4       # Convergence tolerance\nparams.time_limit = 60      # Maximum 60 seconds\nparams.verbose = true       # Print solver output\n\n# Step 3: Solve\nresult = optimize(model, params)\n\n# Check results\nprintln(\"Status: \", result.status)\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: x₁ = \", result.x[1], \", x₂ = \", result.x[2])\nprintln(\"Iterations: \", result.iter)\nprintln(\"Solve time: \", result.time, \" seconds\")\n\nExpected output:\n\nOptimal value: -26.4\nSolution: x₁ ≈ 2.8, x₂ ≈ 3.6","category":"section"},{"location":"getting_started.html#Using-JuMP","page":"Getting Started","title":"Using JuMP","text":"The same problem using the JuMP modeling interface:\n\nusing JuMP\nusing HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n# Set optimizer attributes\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\nset_optimizer_attribute(model, \"use_gpu\", false)\nset_optimizer_attribute(model, \"verbose\", true)\n\n# Define variables and constraints\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, x1 + 2x2 <= 10)\n@constraint(model, 3x1 + x2 <= 12)\n\n# Solve\noptimize!(model)\n\n# Get results\nprintln(\"Status: \", termination_status(model))\nprintln(\"Optimal value: \", objective_value(model))\nprintln(\"Solution: x₁ = \", value(x1), \", x₂ = \", value(x2))\nprintln(\"Solve time: \", solve_time(model), \" seconds\")","category":"section"},{"location":"getting_started.html#Solve-the-instance-from-MPS-Files","page":"Getting Started","title":"Solve the instance from MPS Files","text":"using HPRLP\n\n# Build model from file\nmodel = build_from_mps(\"model.mps\")\n\n# Set parameters\nparams = HPRLP_parameters()\n\n# Solve\nresult = optimize(model, params)","category":"section"},{"location":"getting_started.html#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Learn about solving MPS files\nExplore the Direct API in detail\nSee more JuMP integration examples\nCheck out the full API Reference\nBrowse additional Examples","category":"section"},{"location":"getting_started.html#Performance-Tips","page":"Getting Started","title":"Performance Tips","text":"JIT Compilation: The first run will be slow due to Julia's JIT compilation. For benchmarking, run the solver twice or use a warm-up phase.\nGPU Usage: For large problems (typically > 10,000 variables/constraints), GPU acceleration can provide significant speedups.\nScaling: The default scaling methods (Ruiz and Pock-Chambolle) improve numerical stability. Keep them enabled unless you have specific reasons to disable them.\nTolerance: The default stoptol = 1e-4 is relatively loose. Increase for more accurate solutions in critical applications.","category":"section"},{"location":"guide/parameters.html#Solver-Parameters","page":"Parameters","title":"Solver Parameters","text":"HPRLP provides extensive customization through the HPRLP_parameters type. This guide explains all available parameters and their effects on solver behavior.","category":"section"},{"location":"guide/parameters.html#Parameter-Summary-Table","page":"Parameters","title":"Parameter Summary Table","text":"Parameter Type Default Range/Values Purpose\nstoptol Float64 1e-4 > 0 Convergence tolerance\nmax_iter Int ~2.1B > 0 Maximum iterations\ntime_limit Float64 3600.0 > 0 Time limit (seconds)\ncheck_iter Int 150 > 0 Convergence check interval\nuse_Ruiz_scaling Bool true true/false Ruiz equilibration\nuse_Pock_Chambolle_scaling Bool true true/false Pock-Chambolle scaling\nuse_bc_scaling Bool true true/false b/c vector scaling\nuse_gpu Bool true true/false GPU acceleration\ndevice_number Int 0 ≥ 0 GPU device selection\nwarm_up Bool true true/false GPU warm-up\nprint_frequency Int -1 -1 or > 0 Print interval (-1=auto)\nverbose Bool true true/false Enable output\ninitial_x Vector/Nothing nothing - Initial primal solution\ninitial_y Vector/Nothing nothing - Initial dual solution\nauto_save Bool false true/false Auto-save best solution\nsave_filename String \"hprlp_autosave.h5\" - HDF5 filename for auto-save","category":"section"},{"location":"guide/parameters.html#Creating-Parameters","page":"Parameters","title":"Creating Parameters","text":"using HPRLP\n\n# Create with default values\nparams = HPRLP_parameters()\n\n# Customize as needed\nparams.stoptol = 1e-6\nparams.use_gpu = true\nparams.verbose = true","category":"section"},{"location":"guide/parameters.html#Convergence-Parameters","page":"Parameters","title":"Convergence Parameters","text":"","category":"section"},{"location":"guide/parameters.html#stoptol::Float64","page":"Parameters","title":"stoptol::Float64","text":"Default: 1e-4\n\nStopping tolerance for convergence. The solver terminates when the optimality conditions are satisfied within this tolerance.\n\nparams.stoptol = 1e-9  # Higher accuracy (slower)\nparams.stoptol = 1e-2  # Lower accuracy (faster)","category":"section"},{"location":"guide/parameters.html#max_iter::Int","page":"Parameters","title":"max_iter::Int","text":"Default: typemax(Int32) (≈2.1 billion)\n\nMaximum number of iterations before stopping.\n\nparams.max_iter = 100000  # Limit to 100k iterations","category":"section"},{"location":"guide/parameters.html#time_limit::Float64","page":"Parameters","title":"time_limit::Float64","text":"Default: 3600.0 (1 hour)\n\nMaximum solve time in seconds.\n\nparams.time_limit = 600.0   # 10 minutes\nparams.time_limit = 7200.0  # 2 hours","category":"section"},{"location":"guide/parameters.html#check_iter::Int","page":"Parameters","title":"check_iter::Int","text":"Default: 150\n\nInterval for checking convergence criteria. Lower values check more frequently (higher overhead), higher values check less often (potentially more wasted iterations).\n\nparams.check_iter = 100  # Check more frequently\nparams.check_iter = 200  # Check less frequently","category":"section"},{"location":"guide/parameters.html#Scaling-Parameters","page":"Parameters","title":"Scaling Parameters","text":"Scaling improves numerical stability and convergence. HPRLP supports three types of scaling that can be combined.","category":"section"},{"location":"guide/parameters.html#use_Ruiz_scaling::Bool","page":"Parameters","title":"use_Ruiz_scaling::Bool","text":"Default: true\n\nEnable Ruiz equilibration scaling, which balances the rows and columns of the constraint matrix.\n\nparams.use_Ruiz_scaling = true   # Recommended\nparams.use_Ruiz_scaling = false  # Disable if problem is already well-scaled","category":"section"},{"location":"guide/parameters.html#use_Pock_Chambolle_scaling::Bool","page":"Parameters","title":"use_Pock_Chambolle_scaling::Bool","text":"Default: true\n\nEnable Pock-Chambolle scaling, a diagonal scaling for primal-dual algorithms.\n\nparams.use_Pock_Chambolle_scaling = true  # Recommended","category":"section"},{"location":"guide/parameters.html#use_bc_scaling::Bool","page":"Parameters","title":"use_bc_scaling::Bool","text":"Default: true\n\nEnable scaling for the objective vector (c) and constraint bounds (b).\n\nparams.use_bc_scaling = true  # Recommended for most problems\n\nnote: Scaling Recommendations\nKeep all three scaling options enabled (default) for most problems\nDisable only if you have a well-conditioned problem or specific numerical concerns\nAll three can be used simultaneously for best results","category":"section"},{"location":"guide/parameters.html#GPU-Parameters","page":"Parameters","title":"GPU Parameters","text":"","category":"section"},{"location":"guide/parameters.html#use_gpu::Bool","page":"Parameters","title":"use_gpu::Bool","text":"Default: true\n\nEnable GPU acceleration. Requires CUDA-capable GPU.\n\nparams.use_gpu = true   # Use GPU (much faster for large problems)\nparams.use_gpu = false  # Use CPU only\n\ntip: When to Use GPU\nLarge problems (>10,000 variables): Significant speedup\nSmall problems (<1,000 variables): CPU may be faster due to overhead\nMultiple GPUs available: Use device_number to select specific GPU","category":"section"},{"location":"guide/parameters.html#device_number::Int","page":"Parameters","title":"device_number::Int","text":"Default: 0\n\nGPU device number to use (0-indexed). Only relevant when use_gpu = true.\n\nparams.device_number = 0  # First GPU\nparams.device_number = 1  # Second GPU","category":"section"},{"location":"guide/parameters.html#warm_up::Bool","page":"Parameters","title":"warm_up::Bool","text":"Default: true\n\nTo ensure accurate timing, due to Julia's JIT compilation, a warm-up phase can be performed before the actual solve. This is recommended for benchmarking.\n\nparams.warm_up = true   # Accurate timing (recommended)\nparams.warm_up = false  # Skip warm-up","category":"section"},{"location":"guide/parameters.html#Output-Parameters","page":"Parameters","title":"Output Parameters","text":"","category":"section"},{"location":"guide/parameters.html#verbose::Bool","page":"Parameters","title":"verbose::Bool","text":"Default: true\n\nEnable detailed solver output during optimization.\n\nparams.verbose = true   # Print iteration log\nparams.verbose = false  # Silent mode","category":"section"},{"location":"guide/parameters.html#print_frequency::Int","page":"Parameters","title":"print_frequency::Int","text":"Default: -1 (automatic)\n\nControl how often to print iteration information. When set to -1, frequency is automatically determined.\n\nparams.print_frequency = -1    # Auto (default)\nparams.print_frequency = 100   # Print every 100 iterations\nparams.print_frequency = 1     # Print every iteration (very verbose)","category":"section"},{"location":"guide/parameters.html#Warm-Start-Parameters","page":"Parameters","title":"Warm-Start Parameters","text":"","category":"section"},{"location":"guide/parameters.html#initial_x::Union{Vector{Float64},Nothing}","page":"Parameters","title":"initial_x::Union{Vector{Float64},Nothing}","text":"Default: nothing\n\nInitial primal solution to warm-start the solver.\n\nparams.initial_x = x0  # From previous solve or heuristic","category":"section"},{"location":"guide/parameters.html#initial_y::Union{Vector{Float64},Nothing}","page":"Parameters","title":"initial_y::Union{Vector{Float64},Nothing}","text":"Default: nothing\n\nInitial dual solution to warm-start the solver.\n\nparams.initial_y = y0  # Optional, can use with or without initial_x","category":"section"},{"location":"guide/parameters.html#Auto-Save-Parameters","page":"Parameters","title":"Auto-Save Parameters","text":"","category":"section"},{"location":"guide/parameters.html#auto_save::Bool","page":"Parameters","title":"auto_save::Bool","text":"Default: false\n\nAutomatically save the best solution found during optimization to HDF5.\n\nparams.auto_save = true","category":"section"},{"location":"guide/parameters.html#save_filename::String","page":"Parameters","title":"save_filename::String","text":"Default: \"hprlp_autosave.h5\"\n\nFilename for the HDF5 file used by auto-save.\n\nparams.save_filename = \"my_problem.h5\"","category":"section"},{"location":"guide/parameters.html#Common-Configurations","page":"Parameters","title":"Common Configurations","text":"","category":"section"},{"location":"guide/parameters.html#High-Accuracy","page":"Parameters","title":"High Accuracy","text":"params = HPRLP_parameters()\nparams.stoptol = 1e-9\nparams.time_limit = 15000.0","category":"section"},{"location":"guide/parameters.html#Fast-Approximate-Solutions","page":"Parameters","title":"Fast Approximate Solutions","text":"params = HPRLP_parameters()\nparams.stoptol = 1e-4\nparams.time_limit = 300.0","category":"section"},{"location":"guide/parameters.html#CPU-Only-(No-GPU-Available)","page":"Parameters","title":"CPU-Only (No GPU Available)","text":"params = HPRLP_parameters()\nparams.use_gpu = false","category":"section"},{"location":"guide/parameters.html#Production/Batch-Processing","page":"Parameters","title":"Production/Batch Processing","text":"params = HPRLP_parameters()\nparams.verbose = false\nparams.warm_up = false","category":"section"},{"location":"guide/parameters.html#With-Auto-Save-and-Warm-Start","page":"Parameters","title":"With Auto-Save and Warm-Start","text":"params = HPRLP_parameters()\nparams.auto_save = true\nparams.save_filename = \"backup.h5\"\nparams.initial_x = x0","category":"section"},{"location":"guide/parameters.html#Debugging/Analysis","page":"Parameters","title":"Debugging/Analysis","text":"params = HPRLP_parameters()\nparams.verbose = true\nparams.print_frequency = 1\nparams.check_iter = 1\nparams.max_iter = 100","category":"section"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"Complete, runnable examples demonstrating HPRLP usage. More examples coming soon!\n\nFor detailed guides on each input method, see:\n\nDirect API Guide\nJuMP Integration Guide  \nMPS Files Guide","category":"section"},{"location":"examples.html#Example-1:-Direct-API-Basic-LP","page":"Examples","title":"Example 1: Direct API - Basic LP","text":"Solve a simple 2-variable LP problem using matrices.\n\nusing HPRLP\nusing SparseArrays\n\n# Problem:\n# min  -3x₁ - 5x₂\n# s.t.  x₁ + 2x₂ ≤ 10\n#      3x₁ +  x₂ ≤ 12\n#      x₁, x₂ ≥ 0\n\n# Standard form: AL ≤ Ax ≤ AU\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nc = [-3.0, -5.0]\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\n# Build and solve\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\n\nresult = optimize(model, params)\n\nprintln(\"Status: \", result.status)\nprintln(\"Objective: \", result.primal_obj)\nprintln(\"Solution: x₁ = \", result.x[1], \", x₂ = \", result.x[2])","category":"section"},{"location":"examples.html#Example-2:-MPS-Files","page":"Examples","title":"Example 2: MPS Files","text":"Read and solve a problem from an MPS file.\n\nusing HPRLP\n\n# Build model from file\nmodel = build_from_mps(\"problem.mps\")\n\n# Configure parameters\nparams = HPRLP_parameters()\nparams.stoptol = 1e-6\nparams.use_gpu = true\nparams.verbose = true\n\n# Solve\nresult = optimize(model, params)\n\nif result.status == \"OPTIMAL\"\n    println(\"✓ Optimal solution found!\")\n    println(\"  Objective: \", result.primal_obj)\n    println(\"  Time: \", result.time, \" seconds\")\nend","category":"section"},{"location":"examples.html#Example-3:-JuMP-Integration","page":"Examples","title":"Example 3: JuMP Integration","text":"Build and solve using JuMP's modeling language.\n\nusing JuMP, HPRLP\n\nmodel = Model(HPRLP.Optimizer)\nset_optimizer_attribute(model, \"stoptol\", 1e-4)\n\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, x1 + 2x2 <= 10)\n@constraint(model, 3x1 + x2 <= 12)\n\noptimize!(model)\n\nprintln(\"Status: \", termination_status(model))\nprintln(\"Objective: \", objective_value(model))\nprintln(\"x1 = \", value(x1), \", x2 = \", value(x2))","category":"section"},{"location":"examples.html#Example-4:-Using-Warm-Start","page":"Examples","title":"Example 4: Using Warm-Start","text":"Solve related problems with warm-start.\n\nusing HPRLP\nusing SparseArrays\n\nA = sparse([1.0 2.0; 3.0 1.0])\nc = [-3.0, -5.0]\nAL = [-Inf, -Inf]\nAU = [10.0, 12.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\n# First solve\nmodel = build_from_Abc(A, c, AL, AU, l, u)\nparams = HPRLP_parameters()\nresult1 = optimize(model, params)\n\n# Solve modified problem with warm-start\nAU_new = [11.0, 12.0]\nmodel2 = build_from_Abc(A, c, AL, AU_new, l, u)\nparams.initial_x = result1.x\nparams.initial_y = result1.y\nresult2 = optimize(model2, params)","category":"section"},{"location":"examples.html#Example-5:-Auto-Save-Feature","page":"Examples","title":"Example 5: Auto-Save Feature","text":"Enable auto-save for long optimizations.\n\nusing HPRLP\n\nmodel = build_from_mps(\"large_problem.mps\")\n\nparams = HPRLP_parameters()\nparams.time_limit = 3600\nparams.auto_save = true\nparams.save_filename = \"best_solution.h5\"\n\nresult = optimize(model, params)","category":"section"},{"location":"examples.html#Example-6:-Reading-Auto-Saved-Results","page":"Examples","title":"Example 6: Reading Auto-Saved Results","text":"using HDF5\n\nh5open(\"best_solution.h5\", \"r\") do file\n    x_best = read(file, \"x\")\n    y_best = read(file, \"y\")\n    println(\"Best solution found at iteration: \", read(file, \"iter\"))\nend","category":"section"},{"location":"examples.html#More-Examples","page":"Examples","title":"More Examples","text":"More examples will be added in future releases.","category":"section"},{"location":"guide/direct_api.html#Direct-API-Usage","page":"Direct API","title":"Direct API Usage","text":"The direct API allows you to solve LP problems by passing matrices and vectors directly, without using MPS files or modeling languages.","category":"section"},{"location":"guide/direct_api.html#Basic-Example","page":"Direct API","title":"Basic Example","text":"using HPRLP\nusing SparseArrays\n\n# Problem: min -3x₁ - 5x₂\n#          s.t. x₁ + 2x₂ ≤ 10\n#               3x₁ + x₂ ≤ 12\n#               x₁, x₂ ≥ 0\n\n# Convert to standard form: AL ≤ Ax ≤ AU\nA = sparse([-1.0 -2.0; -3.0 -1.0])  # Note the negation\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nc = [-3.0, -5.0]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\n# Step 1: Build the model\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\n# Step 2: Set parameters\nparams = HPRLP_parameters()\nparams.use_gpu = false\n\n# Step 3: Optimize\nresult = optimize(model, params)\n\nprintln(\"Status: \", result.status)\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: \", result.x)","category":"section"},{"location":"guide/direct_api.html#Standard-Form-Convention","page":"Direct API","title":"Standard Form Convention","text":"HPRLP uses the convention:\n\nbeginarrayll\nmin quad  c^T x \ntextst quad  AL leq Ax leq AU \n l leq x leq u\nendarray","category":"section"},{"location":"guide/direct_api.html#Converting-Common-Forms","page":"Direct API","title":"Converting Common Forms","text":"Original Constraint Set A row Set AL_i Set AU_i\na^T x leq b a^T -infty b\na^T x geq b a^T b +infty\na^T x = b a^T b b\nL leq a^T x leq U a^T L U","category":"section"},{"location":"guide/direct_api.html#Complete-Example-with-All-Constraint-Types","page":"Direct API","title":"Complete Example with All Constraint Types","text":"using HPRLP\nusing SparseArrays\n\n# Problem with mixed constraints:\n# min   x₁ + 2x₂ + 3x₃\n# s.t.  x₁ + x₂ + x₃ = 5      (equality)\n#       x₁ + 2x₂ ≤ 8          (upper bound)\n#       2x₁ + x₃ ≥ 3          (lower bound)\n#       1 ≤ x₂ + x₃ ≤ 6       (two-sided)\n#       0 ≤ x₁ ≤ 5, x₂ ≥ 0, x₃ free\n\n# Constraint matrix\nA = sparse([\n    1.0  1.0  1.0;   # x₁ + x₂ + x₃ = 5\n    1.0  2.0  0.0;   # x₁ + 2x₂ ≤ 8\n    2.0  0.0  1.0;   # 2x₁ + x₃ ≥ 3\n    0.0  1.0  1.0    # 1 ≤ x₂ + x₃ ≤ 6\n])\n\n# Constraint bounds\nAL = [5.0, -Inf, 3.0, 1.0]\nAU = [5.0, 8.0, Inf, 6.0]\n\n# Objective\nc = [1.0, 2.0, 3.0]\n\n# Variable bounds (free variables: l = -Inf, u = Inf)\nl = [0.0, 0.0, -Inf]\nu = [5.0, Inf, Inf]\n\n# Build and solve\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\nparams = HPRLP_parameters()\nparams.use_gpu = false\nparams.verbose = true\n\nresult = optimize(model, params)\n\nprintln(\"\\nResults:\")\nprintln(\"Status: \", result.status)\nprintln(\"Objective: \", result.primal_obj)\nprintln(\"Solution: x = \", result.x)","category":"section"},{"location":"guide/direct_api.html#Working-with-Dense-Matrices","page":"Direct API","title":"Working with Dense Matrices","text":"Dense matrices are automatically converted to sparse format:\n\nusing SparseArrays\n\n# Dense matrix (will be converted automatically with a warning)\nA_dense = [1.0 2.0 3.0;\n           4.0 5.0 6.0;\n           7.0 8.0 9.0]\n\n# build_from_Abc will convert it to sparse automatically\nmodel = build_from_Abc(A_dense, c, AL, AU, l, u)\n\n# Then solve as usual\nparams = HPRLP_parameters()\nresult = optimize(model, params)","category":"section"},{"location":"guide/direct_api.html#Warm-Start-with-Initial-Solutions","page":"Direct API","title":"Warm-Start with Initial Solutions","text":"Provide initial primal/dual solutions to warm-start the solver:\n\n# From previous solve or heuristic\nx0 = [1.0, 2.0]\ny0 = [0.5, 0.3]\n\nparams = HPRLP_parameters()\nparams.initial_x = x0\nparams.initial_y = y0  # Optional\n\nmodel = build_from_Abc(A, c, AL, AU, l, u)\nresult = optimize(model, params)\n\nUseful for solving sequences of related problems or re-solving with different parameters.","category":"section"},{"location":"guide/direct_api.html#Auto-Save-Best-Solution","page":"Direct API","title":"Auto-Save Best Solution","text":"Automatically save the best solution found during optimization to HDF5:\n\nparams = HPRLP_parameters()\nparams.auto_save = true\nparams.save_filename = \"my_optimization.h5\"\n\nresult = optimize(model, params)\n\nUseful for long optimizations that might be interrupted or reach time limits. ```","category":"section"},{"location":"guide/direct_api.html#See-Also","page":"Direct API","title":"See Also","text":"Parameters - Complete guide to solver parameters\nOutput & Results - Understanding solver output and results","category":"section"},{"location":"guide/mps_files.html#Solving-MPS-Files","page":"MPS Files","title":"Solving MPS Files","text":"HPRLP can directly read and solve linear programming problems in MPS (Mathematical Programming System) format, a widely-used industry standard format.","category":"section"},{"location":"guide/mps_files.html#Quick-Start","page":"MPS Files","title":"Quick Start","text":"using HPRLP\n\n# Step 1: Build model from MPS file\nmodel = build_from_mps(\"path/to/problem.mps\")\n\n# Step 2: Configure solver parameters\nparams = HPRLP_parameters()\nparams.stoptol = 1e-4\n\n# Step 3: Optimize\nresult = optimize(model, params)","category":"section"},{"location":"guide/mps_files.html#Working-with-MPS-Files","page":"MPS Files","title":"Working with MPS Files","text":"","category":"section"},{"location":"guide/mps_files.html#Basic-Usage","page":"MPS Files","title":"Basic Usage","text":"using HPRLP\n\n# Build the model\nmodel = build_from_mps(\"model.mps\")\n\n# Set up parameters\nparams = HPRLP_parameters()\n\n# Solve\nresult = optimize(model, params)\n\nif result.status == \"OPTIMAL\"\n    println(\"Found optimal solution!\")\n    println(\"Objective: \", result.primal_obj)\n    println(\"Solution vector: \", result.x)\nelse\n    println(\"Solver stopped with status: \", result.status)\nend","category":"section"},{"location":"guide/mps_files.html#With-Custom-Parameters","page":"MPS Files","title":"With Custom Parameters","text":"# Build model\nmodel = build_from_mps(\"large_problem.mps\")\n\n# Configure parameters\nparams = HPRLP_parameters()\nparams.stoptol = 1e-9          # Higher accuracy\nparams.time_limit = 3600       # 1 hour time limit\nparams.use_gpu = true          # Enable GPU\nparams.verbose = true          # Show progress\nparams.warm_up = true          # Enable warmup for accurate timing\n\n# Solve\nresult = optimize(model, params)\n\ntip: Parameter Reference\nFor detailed explanations of all parameters, see the Parameters guide.","category":"section"},{"location":"guide/mps_files.html#Common-MPS-Sources","page":"MPS Files","title":"Common MPS Sources","text":"","category":"section"},{"location":"guide/mps_files.html#NETLIB","page":"MPS Files","title":"NETLIB","text":"The classic NETLIB LP test set:\n\nDownload from: http://www.netlib.org/lp/data/\nContains problems of various sizes and characteristics\nStandard benchmark for LP solvers","category":"section"},{"location":"guide/mps_files.html#MIPLIB","page":"MPS Files","title":"MIPLIB","text":"Mixed-Integer Programming Library (LP relaxations):\n\nDownload from: https://miplib.zib.de/\nIncludes continuous LP problems\nChallenging real-world instances","category":"section"},{"location":"guide/mps_files.html#Hans-Mittelmann's-Benchmark","page":"MPS Files","title":"Hans Mittelmann's Benchmark","text":"Collection of LP and optimization problems:\n\nhttp://plato.asu.edu/ftp/lptestset/\nRegularly updated\nVarious problem classes","category":"section"},{"location":"guide/mps_files.html#Performance-Tips","page":"MPS Files","title":"Performance Tips","text":"GPU vs CPU: \nUse GPU for large problems (> 10,000 variables/constraints)\nUse CPU for small to medium problems or when GPU is unavailable\nTolerance:\nUse 1e-6 or 1e-8 for high-accuracy requirements\nTime Limits:\nSet reasonable time limits for batch processing\nDefault is 3600 seconds (1 hour)\nScaling:\nKeep scaling enabled for better numerical stability\nDisable only if you have pre-scaled data","category":"section"},{"location":"guide/mps_files.html#See-Also","page":"MPS Files","title":"See Also","text":"Parameters - Complete guide to solver parameters and configuration\nOutput & Results - Understanding and interpreting solver results","category":"section"},{"location":"guide/input_overview.html#Input-Methods-Overview","page":"Overview","title":"Input Methods Overview","text":"HPRLP supports three different ways to specify and solve linear programming problems. Choose the method that best fits your workflow.","category":"section"},{"location":"guide/input_overview.html#Quick-Comparison","page":"Overview","title":"Quick Comparison","text":"Method Best For Key Advantage When to Use\nJuMP Integration Model building in Julia High-level modeling language Building models programmatically with algebraic syntax\nMPS Files Standard format files Industry compatibility Reading benchmarks or problems from other tools\nDirect API Matrix-based input Full control, no overhead Working with pre-built matrices or custom algorithms","category":"section"},{"location":"guide/input_overview.html#Choosing-Your-Input-Method","page":"Overview","title":"Choosing Your Input Method","text":"","category":"section"},{"location":"guide/input_overview.html#Use-JuMP-Integration-if-you:","page":"Overview","title":"Use JuMP Integration if you:","text":"✓ Want to build models using algebraic expressions\n✓ Need a high-level, readable problem formulation\n✓ Are familiar with optimization modeling languages (like AMPL, GAMS)\n✓ Want to easily switch between different solvers\n✓ Prefer working with variables, constraints, and objectives directly\n\nExample use case: Building a production planning model where you define decision variables and constraints naturally.\n\nusing JuMP, HPRLP\nmodel = Model(HPRLP.Optimizer)\n@variable(model, x >= 0)\n@variable(model, y >= 0)\n@objective(model, Max, 3x + 5y)\n@constraint(model, x + 2y <= 10)\noptimize!(model)\n\n→ See JuMP Integration Guide\n\n","category":"section"},{"location":"guide/input_overview.html#Use-MPS-Files-if-you:","page":"Overview","title":"Use MPS Files if you:","text":"✓ Have problems in MPS format from benchmarks (NETLIB, MIPLIB, etc.)\n✓ Need to read problems generated by other optimization tools\n✓ Want to use standard LP test sets\n✓ Are comparing solver performance on established benchmarks\n✓ Receive problem files from collaborators or other software\n\nExample use case: Solving benchmark problems from the NETLIB test set or problems exported from commercial optimization software.\n\nusing HPRLP\nmodel = build_from_mps(\"path/to/problem.mps\")\nparams = HPRLP_parameters()\nresult = optimize(model, params)\n\n→ See MPS Files Guide\n\n","category":"section"},{"location":"guide/input_overview.html#Use-Direct-API-if-you:","page":"Overview","title":"Use Direct API if you:","text":"✓ Already have your problem in matrix form\n✓ Need maximum performance (no modeling overhead)\n✓ Are implementing custom algorithms or research code\n✓ Work with problems generated from scientific computing\n✓ Want precise control over the problem formulation\n✓ Are integrating HPRLP into existing numerical code\n\nExample use case: Solving LP subproblems in a decomposition algorithm where constraint matrices are built programmatically.\n\nusing HPRLP, SparseArrays\nA = sparse([...])  # Your constraint matrix\nmodel = build_from_Abc(A, c, AL, AU, l, u)\nparams = HPRLP_parameters()\nresult = optimize(model, params)\n\n→ See Direct API Guide\n\n","category":"section"},{"location":"guide/input_overview.html#Can-I-Use-Multiple-Methods?","page":"Overview","title":"Can I Use Multiple Methods?","text":"Yes! You can use different input methods in the same project. For example:\n\nUse JuMP for rapid prototyping, then switch to Direct API for production\nValidate your Direct API implementation against MPS benchmark files\nBuild models in JuMP and export/import via MPS format","category":"section"},{"location":"guide/input_overview.html#What's-Next?","page":"Overview","title":"What's Next?","text":"Choose your input method using the guide above\nConfigure solver parameters in the Parameters guide\nUnderstand the results in the Output & Results guide","category":"section"},{"location":"guide/input_overview.html#Standard-Form","page":"Overview","title":"Standard Form","text":"Regardless of input method, HPRLP internally solves problems in the standard form:\n\nbeginarrayll\nmin quad  c^T x + c_0\ntextst quad  AL leq Ax leq AU \n l leq x leq u\nendarray\n\nJuMP automatically converts your model to this form\nMPS files are parsed into this representation  \nDirect API lets you specify this form directly","category":"section"},{"location":"index.html#HPRLP.jl-Documentation","page":"Home","title":"HPRLP.jl Documentation","text":"A Julia implementation of the Halpern Peaceman-Rachford (HPR) method for solving linear programming (LP) problems on the GPU.","category":"section"},{"location":"index.html#Overview","page":"Home","title":"Overview","text":"HPRLP.jl is a high-performance linear programming solver that leverages GPU acceleration to solve large-scale LP problems efficiently. It implements the Halpern Peaceman-Rachford splitting method with adaptive restart strategy and penalty parameter selection.","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"✅ GPU Acceleration: Native CUDA support for solving large-scale problems\n✅ CPU Support: Support CPU mode when GPU is not available\n✅ Multiple Inputs: \nDirect API with matrix inputs\nMPS file format support\nJuMP integration via MOI wrapper\n✅ Flexible Scaling: Ruiz, Pock-Chambolle, and scalar scaling methods\n✅ Adaptive Algorithms: Automatic restart strategy and penalty parameter selection","category":"section"},{"location":"index.html#Problem-Formulation","page":"Home","title":"Problem Formulation","text":"HPRLP solves linear programming problems of the form:\n\nbeginarrayll\nundersetx in mathbbR^nmin quad  langle c x rangle \ntextst quad  L leq A x leq U \n l leq x leq u \nendarray\n\nwhere:\n\nx in mathbbR^n is the decision variable\nc in mathbbR^n is the objective coefficient vector\nA in mathbbR^m times n is the constraint matrix\nL U in mathbbR^m are lower and upper bounds on constraints\nl u in mathbbR^n are lower and upper bounds on variables","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"From GitHub (recommended for applications):\n\nusing Pkg\nPkg.add(url=\"https://github.com/PolyU-IOR/HPR-LP\")\n\nLocally (recommended for development):\n\ngit clone https://github.com/PolyU-IOR/HPR-LP.git\ncd HPR-LP\njulia --project=. -e 'using Pkg; Pkg.instantiate()'","category":"section"},{"location":"index.html#Simple-Example","page":"Home","title":"Simple Example","text":"using HPRLP\nusing SparseArrays\n\n# Define LP: min -3x₁ - 5x₂ s.t. x₁ + 2x₂ ≤ 10, 3x₁ + x₂ ≤ 12, x ≥ 0\nA = sparse([-1.0 -2.0; -3.0 -1.0])\nc = [-3.0, -5.0]\nAL = [-10.0, -12.0]\nAU = [Inf, Inf]\nl = [0.0, 0.0]\nu = [Inf, Inf]\n\n# Build and solve\nmodel = build_from_Abc(A, c, AL, AU, l, u)\n\nparams = HPRLP_parameters()\nparams.stoptol = 1e-9  # Set stopping tolerance\n\nresult = optimize(model, params)\n\nprintln(\"Optimal value: \", result.primal_obj)\nprintln(\"Solution: x = \", result.x)","category":"section"},{"location":"index.html#With-JuMP","page":"Home","title":"With JuMP","text":"using JuMP, HPRLP\n\nmodel = Model(HPRLP.Optimizer)\n\n@variable(model, x1 >= 0)\n@variable(model, x2 >= 0)\n@objective(model, Min, -3x1 - 5x2)\n@constraint(model, x1 + 2x2 <= 10)\n@constraint(model, 3x1 + x2 <= 12)\n\nset_attribute(model, \"stoptol\", 1e-9)  # Set stopping tolerance\n\noptimize!(model)\nprintln(\"Objective: \", objective_value(model))\nprintln(\"x1 = \", value(x1), \", x2 = \", value(x2))","category":"section"},{"location":"index.html#Documentation-Contents","page":"Home","title":"Documentation Contents","text":"Pages = [\n    \"getting_started.md\",\n    \"guide/mps_files.md\",\n    \"guide/direct_api.md\",\n    \"guide/jump_integration.md\",\n    \"api.md\",\n    \"examples.md\",\n]\nDepth = 2","category":"section"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"If you use HPRLP in your research, please cite:\n\n@article{chen2025hpr,\n  title={HPR-LP: An implementation of an HPR method for solving linear programming.},\n  author={Chen, Kaihuang and Sun, Defeng and Yuan, Yancheng and Zhang, Guojun and Zhao, Xinyuan},\n  journal={Mathematical Programming Computation},\n  pages={1--28},\n  year={2025},\n  publisher={Springer}\n}","category":"section"},{"location":"index.html#License","page":"Home","title":"License","text":"HPRLP.jl is licensed under the MIT License. See LICENSE for details.","category":"section"}]
}
